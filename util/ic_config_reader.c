/* Copyright (C) 2007-2009 iClaustron AB

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; version 2 of the License.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */

#include <ic_base_header.h>
#include <ic_err.h>
#include <ic_debug.h>
#include <ic_port.h>
#include <ic_mc.h>
#include <ic_string.h>
#include <ic_config_reader.h>

/*
  MODULE: GENERIC_CONFIG_READER
  This module is a generic reader of configuration files.
  It has one external routine:
  build_config_data
  This routine will call into the supplied ic_config_operations
  methods. Those methods will build the actual data structures
  generated by a specific configuration file.
*/

const guint32 MAX_LINE_LEN = 120;

const gchar *false_str= "false";
const gchar *true_str= "true";

static gboolean
ic_check_digit(gchar c)
{
  if (c < '0' || c > '9')
    return FALSE;
  return TRUE;
}

gchar*
ic_convert_file_to_dir(gchar *buf, gchar *file_name)
{
  gchar *buf_start= buf;
  gchar *last_separator= NULL;
  gchar separator;

#ifndef WINDOWS
  separator= '\\';
#else
  separator= '/';
#endif
  while (*file_name)
  {
    *buf= *file_name;
    if (*buf == separator)
      last_separator= buf+1;
    buf++;
    file_name++;
  }
  if (last_separator)
  {
    /*
      We found a separator, thus filename contains a directory part.
      We insert a 0 after this separator to remove filename
      part from the full pathname.
    */
    *last_separator= 0;
  }
  else
  {
    /*
       We found no separator, thus the directory part is empty and we return
       an empty string.
    */
    *buf_start= 0;
  }
  return buf_start;
}

int
ic_conv_config_str_to_int(guint64 *value, IC_STRING *ic_str)
{
  guint32 i;
  guint64 number= 0;
  gboolean no_digit_found= FALSE;

  if (!ic_cmp_null_term_str(false_str, ic_str))
    return 0;
  else if (!ic_cmp_null_term_str(true_str, ic_str))
  {
    number= 1;
    return 0;
  }
  for (i= 0; i < ic_str->len; i++)
  {
    if (no_digit_found)
      return 1;
    if (ic_check_digit(ic_str->str[i]))
    {
      number*= 10;
      number+= (ic_str->str[i] - '0');
    }
    else
    {
      no_digit_found= TRUE;
      if ((ic_str->str[i] == 'k') ||
          (ic_str->str[i] == 'K'))
        number*= 1024;
      else if ((ic_str->str[i] == 'm') ||
               (ic_str->str[i] == 'M'))
        number*= (1024*1024);
      else if ((ic_str->str[i] == 'g') ||
               (ic_str->str[i] == 'G'))
        number*= (1024*1024*1024);
      else
        return 1;
    }
  }
  *value= number;
  return 0;
}

int
ic_conv_str_to_int(gchar *str, guint64 *number, guint32 *len)
{
  gchar *rev_str;
  guint32 str_len;
  guint64 base= 1;
  guint64 this_number;
  gchar end_char;
  gchar reverse_str[64];
  DEBUG_ENTRY("ic_conv_str_to_int");
  rev_str= reverse_str;
  *number= 0;

  for (str_len= 0; str_len < 62; str_len++)
  {
    if (!ic_check_digit(str[str_len]))
      break;
  }
  if (str_len > 60 || str_len == 0)
    return 1;
  end_char= str[str_len];
  if (len)
    *len= str_len;
  ic_reverse_str(str, rev_str, end_char);
  while (*rev_str != end_char)
  {
    this_number= (*rev_str - '0');
    *number= *number + (this_number * base);
    base *= 10;
    rev_str++;
  }
  return 0;
}

static
guint32 read_cr_line(gchar *iter_data)
{
  gsize len= 1;
  do
  {
    gchar iter_char= *iter_data;
    if (iter_char == CARRIAGE_RETURN ||
        iter_char == 0)
      return len;
    len++;
    iter_data++;
  } while (len < MAX_LINE_LEN);
  return 0;
}

static
gchar *conv_group_id(gchar *group_id, guint32 len)
{
  guint32 iter_len= 0;
  gchar *save_group_id= group_id;
  while (iter_len < len)
  {
    gchar c= *group_id;
    if (g_ascii_isalpha(c))
    {
      c= g_ascii_tolower(c);
      *group_id= c;
    }
    else if (c != ' ')
      return NULL;
    group_id++;
    iter_len++;
  }
  return save_group_id;    
}

static
gchar *conv_key_id(gchar *key_id, guint32 *len)
{
  gchar *save_key_id= key_id;
  guint32 iter_len= 0;
  while (iter_len < *len)
  {
    gchar c= *key_id;
    if (!g_ascii_isalpha(c) && c != '_')
    {
      *len= iter_len;
      return save_key_id;
    }
    *key_id= g_ascii_tolower(c);
    iter_len++;
    key_id++;
  }
  return NULL;
}

static
gchar *rm_space(gchar *val_str, guint32 *iter_len, guint32 len)
{
  for ( ; 
       (g_ascii_isspace(val_str[0]) ||
        val_str[0] == '\t')
       && *iter_len < len;
       val_str++, (*iter_len)++)
    ;
  return val_str;
}

static
gchar *conv_key_value(gchar *val_str, guint32 *len)
{
  gboolean found= FALSE;
  guint32 iter_len= 0;
  gchar *save_val_str;
  gchar *first_val_str= val_str;

  val_str= rm_space(val_str, &iter_len, *len);
  if (*len == iter_len || (val_str[0] != '=' && val_str[0] != ':'))
    return NULL;
  val_str++;
  iter_len++;
  val_str= rm_space(val_str, &iter_len, *len);
  save_val_str= val_str;
  while (iter_len < *len)
  {
    gchar c= *val_str;
    if (!(g_ascii_isalpha(c) || c == '/' || c == '\\' ||
        g_ascii_isdigit(c) || '.' ||
        c == '_' || g_ascii_isspace(c)))
      return NULL;
    val_str++;
    iter_len++;
    found= TRUE;
  }
  if (!found)
    return NULL;
  *len= (guint32)(((first_val_str + *len) - save_val_str) - 1);
  return save_val_str;
}

static
guint32 read_config_line(IC_CONFIG_OPERATIONS *conf_ops,
                         IC_CONFIG_STRUCT *conf_obj,
                         IC_STRING *line_data,
                         guint32 line_number,
                         guint32 *section_num,
                         guint32 pass)
{
  gchar *iter_data= line_data->str;
  guint32 line_len= line_data->len;
  DEBUG_ENTRY("read_config_line");

  if (line_len == 1)
  {
    DEBUG_PRINT(CONFIG_LEVEL,
      ("Line number %d in section %d is an empty line", line_number,
       *section_num));
    return 0;
  }
  else if (*iter_data == '#')
  {
    /*
      We have found a correct comment line, report it to the configuration
      object.
    */
    IC_STRING comment_str;
    IC_INIT_STRING(&comment_str, iter_data, line_len, FALSE);
    return conf_ops->ic_add_comment(conf_obj, line_number, *section_num,
                                    &comment_str, pass);
  }
  else if (*iter_data == '[')
  {
    if (iter_data[line_len - 2] != ']')
      return IC_ERROR_CONFIG_BRACKET;
    else
    {
      IC_STRING section_name;
      guint32 group_id_len= line_len - 3;
      gchar *group_id= conv_group_id(&iter_data[1], group_id_len);
      if (!group_id)
        return IC_ERROR_CONFIG_INCORRECT_GROUP_ID;
      /*
        We have found a correct group id, now tell the configuration
        object about this and let him decide if this group id is
        correct according to the definition of this configuration
        object.
      */
      IC_INIT_STRING(&section_name, group_id, group_id_len, FALSE);
      (*section_num)++;
      return conf_ops->ic_add_section(conf_obj, *section_num, line_number,
                                      &section_name, pass);
    }
  }
  else
  {
    IC_STRING key_name, data_str;
    guint32 id_len= line_len;
    guint32 val_len= 0;
    guint32 space_len= 0;
    gchar *key_id= NULL;
    gchar *val_str= NULL;

    rm_space(iter_data, &space_len, line_len);
    id_len-= space_len;
    if (!(key_id= conv_key_id(&iter_data[space_len], &id_len)) ||
        ((val_len= line_len - (id_len + space_len)), FALSE) ||
        (!(val_str= conv_key_value(&iter_data[id_len+space_len], &val_len))))
      return IC_ERROR_CONFIG_IMPROPER_KEY_VALUE;
    /*
      We have found a correct key-value pair. Now let the configuration object
      decide whether this key and value makes sense and if so insert it into
      the configuration.
    */
    IC_INIT_STRING(&key_name, key_id, id_len, FALSE);
    IC_INIT_STRING(&data_str, val_str, val_len, FALSE);
    return conf_ops->ic_add_key(conf_obj, *section_num, line_number,
                                &key_name, &data_str, pass);
  }
}
/*
  This method is used to build the configuration data structure from reading
  the configuration file. It's designed to be reusable for any type of
  configuration file. The configuration file is always read in two passes,
  the first usually gathers some information about size of various parts.
  
  PARAMETERS:
  conf_data      This parameter contains the configuration file as a long string
  ic_conf_op     This contains the function pointers for this specific config
                 file type
  ic_config      This contains the pointer to the data structure where the
                 configuration data is placed, this is done through a union
                 of pointers to one struct per configuration file type
  err_obj        Any error information is returned in this object
*/

int ic_build_config_data(IC_STRING *conf_data,
                         IC_CONFIG_STRUCT *ic_config,
                         IC_CONFIG_ERROR *err_obj)
{
  guint32 line_number;
  guint32 line_length, pass;
  int error;
  guint32 section_num;
  IC_STRING line_data;
  IC_CONFIG_OPERATIONS *ic_conf_op= ic_config->clu_conf_ops;
  DEBUG_ENTRY("ic_build_config_data");

  if (conf_data->len == 0)
  {
    err_obj->err_num= 1;
    err_obj->line_number= 0;
    return 1;
  }
  for (pass= 0; pass < 2; pass++)
  {
    gchar *iter_data= conf_data->str;
    gsize iter_data_len= 0;
    line_number= 1;
    section_num= 0;
    if ((error= ic_conf_op->ic_config_init(ic_config, pass)))
      goto config_error;
    while (iter_data_len < conf_data->len)
    {
      if (*iter_data == LINE_FEED)
      {
        /* Special handling of Windows Line Feeds after Carriage Return */
        DEBUG_PRINT(CONFIG_LEVEL, ("Special case"));
        iter_data_len++;
        iter_data++;
        continue;
      }
      error= IC_ERROR_CONFIG_LINE_TOO_LONG;
      if (!(line_length= read_cr_line(iter_data)))
        goto config_error;
      IC_INIT_STRING(&line_data, iter_data, line_length, FALSE);
      if ((error= read_config_line(ic_conf_op, ic_config,
                                   &line_data, line_number, &section_num,
                                   pass)))
        goto config_error;
      iter_data+= line_length;
      iter_data_len+= line_length;
      line_number++;
    }
  }
  if ((error= ic_conf_op->ic_config_verify(ic_config)))
    goto config_error;
  return 0;
config_error:
  ic_conf_op->ic_config_end(ic_config);
  err_obj->err_num= error;
  err_obj->line_number= line_number;
  return 1;
}

