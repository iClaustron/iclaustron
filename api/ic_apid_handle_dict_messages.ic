/* Copyright (C) 2009, 2016 iClaustron AB

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; version 2 of the License.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */

/*
  Metadata transaction execution
  ------------------------------
*/

static void
sendSCHEMA_TRANS_BEGIN_REQ(IC_INT_METADATA_TRANSACTION *md_trans);

static void
sendCREATE_HASH_MAP_REQ(IC_INT_METADATA_TRANSACTION *md_trans);

static IC_DYNAMIC_ARRAY*
fill_create_table_info_properties(IC_INT_ALTER_TABLE *alter_table);

static void
sendCREATE_TABLE_REQ(IC_INT_METADATA_TRANSACTION *md_trans,
                     IC_INT_ALTER_TABLE *alter_table);

static void
sendSCHEMA_TRANS_END_REQ(IC_INT_METADATA_TRANSACTION *md_trans);

static void
print_data(guint32 *print_array, guint32 *current)
{
  guint32 i;

  if (*current == 0)
    return;
  for (i= *current; i < 8; i++)
  {
    print_array[i]= 0xFFFFFFFE;
  }
  *current= 0;
  ic_printf("%.8x  %.8x  %.8x  %.8x  %.8x %.8x %.8x %.8x",
            print_array[0], print_array[1],
            print_array[2], print_array[3],
            print_array[4], print_array[5],
            print_array[6], print_array[7]);
}

static void
print_ndb_message_error(IC_NDB_MESSAGE *ndb_message)
{
  guint32 i, j;
  guint32 current;
  guint32 print_array[8];

  ic_printf("Message to non-existing receiver, message id = %u"
            ", prio: %u",
            ndb_message->message_id,
            ndb_message->message_priority);

  ic_printf("Sender module: %u, Sender node: %u, message number: %u"
            "num segments: %u, recv module: %u, recv node: %u",
            ndb_message->sender_module_id,
            ndb_message->sender_node_id,
            ndb_message->message_number,
            ndb_message->num_segments,
            ndb_message->receiver_module_id,
            ndb_message->receiver_node_id);

  for (i= 0; i < ndb_message->num_segments; i++)
  {
    if (i == 0)
    {
      ic_printf("Message data: len = %u",
                ndb_message->segment_size[i]);
    }
    else
    {
      ic_printf("Data segment %u, len = %u",
               (i-1),
               ndb_message->segment_size[i]);
    }
    for (j= 0; j < ndb_message->segment_size[i]; j++)
    {
      print_array[current++]= ndb_message->segment_ptr[i][j];
      if (current == 8)
        print_data(print_array, &current);
    }
    print_data(print_array, &current);
  }
  return;
}

/**
  Error handling methods
  ----------------------

  There are three types of errors that we can experience in the
  metadata transaction handling.

  The first type is the errors found in the NDB kernel, they are
  found through some kind of message with an error code and we
  can handle this error in an appropriate manner. We categorize
  these errors as external errors and give them appropriate error
  level based on whether they are NDB errors or the user have made
  some error.

  The second type of errors is due to memory allocation failure, out
  of send buffers and internal errors in the iClaustron API code. All
  of these errors make it impossible to continue with the meta data
  transaction, it's also not possible to inform the NDB kernel about
  this error, so we have to rely on that the API user will take proper
  action when the error is an internal error. Otherwise we have to rely
  on the NDB kernel to discover eventually that the transaction was
  aborted.

  The third type of errors is when we fail to send a message, this could
  happen for a number of reasons such as: TCP/IP connection broken to
  node, out of send buffers, error in node id or cluster id or we have
  somehow discovered that the node to communicate is down. In all of those
  cases it is impossible to communicate with the node anymore and we
  will treat the error as an internal error. The NDB node is either already
  dead or will discover eventually that we consider it dead. So it will
  be able to recover from the lost transaction participant.
*/

static void
md_trans_set_ndb_error(IC_INT_METADATA_TRANSACTION *md_trans,
                       guint32 error_line,
                       guint32 error_node_id,
                       guint32 master_node_id)
{
  DEBUG_ENTRY("md_trans_set_ndb_error");
  DEBUG_PRINT(NDB_MESSAGE_LEVEL,
    ("error_line = %u, error_node_id = %u, master_node_id = %u",
     error_line, error_node_id, master_node_id));

  md_trans->error_object.error_line= error_line;
  md_trans->error_object.error_node_id= error_node_id;
  md_trans->error_object.master_node_id= master_node_id;
  DEBUG_RETURN_EMPTY;
}

static void
md_trans_set_internal_error(IC_INT_METADATA_TRANSACTION *md_trans,
                            int ret_code)
{
  DEBUG_ENTRY("md_trans_set_internal_error");
  DEBUG_PRINT(NDB_MESSAGE_LEVEL,
    ("ret_code = %d", ret_code));
  md_trans->return_to_api= TRUE;
  md_trans->error_object.error_code= ret_code;
  md_trans->error_object.error_category= IC_CATEGORY_INTERNAL_ERROR;
  md_trans->error_object.error_severity= IC_SEVERITY_STOP_ERROR;
  DEBUG_RETURN_EMPTY;
}

static void
md_trans_set_external_error(IC_INT_METADATA_TRANSACTION *md_trans,
                            int error_code)
{
  DEBUG_ENTRY("md_trans_set_external_error");
  DEBUG_PRINT(NDB_MESSAGE_LEVEL,
    ("error_code = %d", error_code));
  md_trans->return_to_api= TRUE;
  md_trans->error_object.error_code= error_code;
  md_trans->error_object.error_category= IC_CATEGORY_EXTERNAL_ERROR;

  switch (error_code)
  {
    case SCHEMA_TRANS_MASTER_BUSY:
    case SCHEMA_TRANS_MASTER_NR_BUSY:
    case SCHEMA_TRANS_WRONG_MASTER:
    case SCHEMA_TRANS_NODE_FAILURE:
    case SCHEMA_TRANS_OUT_OF_MEMORY:
    case SCHEMA_TRANS_TOO_MANY_TRANS:
    case SCHEMA_TRANS_ABORTED:
    case SCHEMA_TRANS_BACKUP_IN_PROGRESS:
    case SCHEMA_TRANS_DROP_IN_PROGRESS:
    case SCHEMA_TRANS_NO_DROP_TABLE_RESOURCES:
    case SCHEMA_TRANS_ACTIVE_SCHEMA_TRANSACTION:
      DEBUG_PRINT(NDB_MESSAGE_LEVEL, ("Temporary error"));
      md_trans->error_object.error_severity= IC_SEVERITY_TEMPORARY_ERROR;
      break;
    case SCHEMA_TRANS_INCOMPATIBLE_VERSIONS:
    case SCHEMA_TRANS_INVALID_NDB_TRANSID:
    case SCHEMA_TRANS_INVALID_MY_TRANSID:
    case SCHEMA_TRANS_INVALID_STATE:
    case SCHEMA_TRANS_INCONSISTENCY:
    case SCHEMA_TRANS_TABLE_DEF_TOO_BIG:
    case SCHEMA_TRANS_REQUIRES_UPGRADE:
    case SCHEMA_TRANS_OUT_OF_BUFFER:
    case SCHEMA_TRANS_TRIGGER_NOT_FOUND:
    case SCHEMA_TRANS_TRIGGER_ALREADY_THERE:
    case SCHEMA_TRANS_BAD_REQUEST:
    case SCHEMA_TRANS_INDEX_ALLOCATION_ERROR:
    case SCHEMA_TRANS_CREATE_INDEX_TABLE_FAILURE:
    case SCHEMA_TRANS_INVALID_TABLE_VERSION:
    case SCHEMA_TRANS_BAD_STATE:
    case SCHEMA_TRANS_INDEX_INCONSISTENCY:
      DEBUG_PRINT(NDB_MESSAGE_LEVEL, ("Error"));
      md_trans->error_object.error_severity= IC_SEVERITY_ERROR;
      break;
    case SCHEMA_TRANS_OUT_OF_TABLE_RECORDS:
    case SCHEMA_TRANS_OUT_OF_COLUMN_RECORDS:
    case SCHEMA_TRANS_COLUMN_NAME_TOO_LONG:
    case SCHEMA_TRANS_TABLE_NAME_TOO_LONG:
    case SCHEMA_TRANS_COLUMN_NAME_TWICE:
    case SCHEMA_TRANS_TABLE_ALREADY_EXIST:
    case SCHEMA_TRANS_INVALID_ARRAY_SIZE:
    case SCHEMA_TRANS_ARRAY_SIZE_TOO_BIG:
    case SCHEMA_TRANS_RECORD_SIZE_TOO_BIG:
    case SCHEMA_TRANS_INVALID_PRIMARY_KEY_SIZE:
    case SCHEMA_TRANS_NULLABLE_PRIMARY_KEY:
    case SCHEMA_TRANS_INVALID_CHARSET:
    case SCHEMA_TRANS_SINGLE_USER:
    case SCHEMA_TRANS_INVALID_TABLESPACE:
    case SCHEMA_TRANS_INVALID_TABLESPACE_VERSION:
    case SCHEMA_TRANS_NO_LOGGING_TEMPORARY_TABLE:
    case SCHEMA_TRANS_INVALID_HASH_MAP:
    case SCHEMA_TRANS_TOO_MANY_FRAGMENTS:
    case SCHEMA_TRANS_NO_TABLESPACE:
    case SCHEMA_TRANS_NO_SUCH_TABLE:
    case SCHEMA_TRANS_CHANGE_NOT_SUPPORTED:
    case SCHEMA_TRANS_INDEX_COLUMN_ON_DISK:
    case SCHEMA_TRANS_TABLE_IS_TEMPORARY_INDEX_ERROR:
    case SCHEMA_TRANS_TABLE_ISNT_TEMPORARY_INDEX_ERROR:
    case SCHEMA_TRANS_INDEX_NAME_TOO_LONG:
    case SCHEMA_TRANS_TOO_MANY_INDEXES:
    case SCHEMA_TRANS_INDEX_EXISTS:
    case SCHEMA_TRANS_COLUMN_NULLABLE:
    case SCHEMA_TRANS_INVALID_INDEX_NAME:
    case SCHEMA_TRANS_INVALID_PRIMARY_TABLE:
    case SCHEMA_TRANS_INVALID_INDEX_TYPE:
    case SCHEMA_TRANS_INDEX_NOT_UNIQUE:
    case SCHEMA_TRANS_DUPLICATE_COLUMN_IN_INDEX:
    case SCHEMA_TRANS_INDEX_NOT_FOUND:
    case SCHEMA_TRANS_NOT_AN_INDEX:
      DEBUG_PRINT(NDB_MESSAGE_LEVEL, ("User error"));
      md_trans->error_object.error_severity= IC_SEVERITY_ERROR;
      md_trans->error_object.error_category= IC_CATEGORY_USER_ERROR;
      break;
    default:
      DEBUG_PRINT(NDB_MESSAGE_LEVEL, ("Other error"));
      md_trans->error_object.error_severity= IC_SEVERITY_ERROR;
      break;
  }
  DEBUG_RETURN_EMPTY;
}

static IC_INT_METADATA_TRANSACTION*
get_metadata_transaction_from_message(IC_NDB_MESSAGE *ndb_message,
                                      guint32 index)
{
  int ret_code;
  void *object;
  IC_REFERENCE_CONTAINER *container;
  IC_INT_METADATA_TRANSACTION *md_trans;
  IC_INT_APID_GLOBAL *apid_global= ndb_message->apid_conn->apid_global;
  IC_DYNAMIC_PTR_ARRAY *map_array= apid_global->dynamic_map_array;

  if ((ret_code= map_array->dpa_ops.ic_get_ptr(map_array,
                                               (guint64)index,
                                               &object)))
    goto error;

  container= (IC_REFERENCE_CONTAINER*)object;
  md_trans= (IC_INT_METADATA_TRANSACTION*)container->reference;
  if (container->ref_type == IC_MD_TRANS)
    return md_trans;
error:
  print_ndb_message_error(ndb_message);
  return NULL;
  
}

/**
  This method is called for all types of metadata transactions. It is
  a blocking call and is completed when the transaction is completed
  or after an extensive timeout indicates that the data node for some
  reason got stuck with the request.
*/
static int
execute_meta_data_transaction(IC_INT_METADATA_TRANSACTION *md_trans)
{
  int ret_code;
  IC_INT_APID_CONNECTION *apid_conn= md_trans->apid_conn;
  IC_INT_APID_GLOBAL *apid_global= apid_conn->apid_global;
  IC_APID_GLOBAL *ext_apid_global= (IC_APID_GLOBAL*)apid_global;
  IC_DYNAMIC_PTR_ARRAY *map_array= apid_global->dynamic_map_array;
  IC_REFERENCE_CONTAINER container;
  guint64 index;
  DEBUG_ENTRY("execute_meta_data_transaction");

  /**
    We need to insert a map object to ensure we can get back to our
    metadata transaction when we receive a message.
  */
  container.reference= md_trans;
  container.ref_type= IC_MD_TRANS;
  if ((ret_code= map_array->dpa_ops.ic_insert_ptr(map_array,
                                                  &index,
                                                  &container)))
    goto error;
  md_trans->my_trans_ref= (guint32)index;

  if ((ret_code= ext_apid_global->apid_global_ops->ic_get_master_node_id(
      ext_apid_global,
      md_trans->cluster_id,
      &md_trans->node_id)))
    goto error;

  /**
    All metadata transactions start by sending SCHEMA_TRANS_BEGIN to
    start a new metadata transaction, the metadata transaction object
    contains all information about what more things that should be
    part of this metadata transaction and how to proceed from there.
  */
  sendSCHEMA_TRANS_BEGIN_REQ(md_trans);
  /* Poll waiting for messages until we're done */
  while (!md_trans->return_to_api)
  {
    ic_poll_messages((IC_APID_CONNECTION*)apid_conn,
                     3 * IC_MICROSEC_PER_SECOND);
  }
  ic_require((map_array->dpa_ops.ic_remove_ptr(map_array,
                                               index,
                                               &container)) == 0);
  DEBUG_RETURN_INT(md_trans->error_object.apid_error_ops->
           ic_get_apid_error_code((IC_APID_ERROR*)&md_trans->error_object));
error:
  DEBUG_RETURN_INT(ret_code);
}

static void
sendSCHEMA_TRANS_BEGIN_REQ(IC_INT_METADATA_TRANSACTION *md_trans)
{
  IC_SCHEMA_TRANS_BEGIN_REQ begin_req;
  guint32 our_reference;
  int ret_code;
  guint32 len= SCHEMA_TRANS_BEGIN_REQ_LEN;
  void *message_ptr;
  IC_INT_APID_CONNECTION *apid_conn= md_trans->apid_conn;
  IC_INT_APID_GLOBAL *apid_global= apid_conn->apid_global;
  DEBUG_ENTRY("sendSCHEMA_TRANS_BEGIN_REQ");

  /* Get our NDB reference */
  our_reference= ic_get_ic_reference(apid_global->my_node_id,
                                     apid_conn->thread_id);

  /* Set up message data for NDB_MD_TRANS_START_REQ */
  begin_req.my_reference= our_reference;
  begin_req.my_transaction_id= md_trans->my_trans_ref;
  begin_req.flags= 0;
  message_ptr= &begin_req;

  md_trans->state= IC_WAIT_SCHEMA_TRANS_BEGIN_CONF;

  ret_code= send_message(apid_conn,
                         SCHEMA_TRANS_BEGIN_REQ_GSN,
                         1, /* No extra segments */
                         &message_ptr,
                         &len,
                         md_trans->cluster_id,
                         md_trans->node_id,
                         IC_NDB_DICT_MODULE,
                         0);
  if (ret_code)
  {
    md_trans_set_internal_error(md_trans, ret_code);
  }
  DEBUG_RETURN_EMPTY;
}

static void
execSCHEMA_TRANS_BEGIN_REF_v0(IC_NDB_MESSAGE *ndb_message)
{
  guint32 our_trans_id= 0;
  IC_SCHEMA_TRANS_BEGIN_REF *ref=
    (IC_SCHEMA_TRANS_BEGIN_REF*)ndb_message->segment_ptr[0];
  IC_INT_METADATA_TRANSACTION *md_trans;
  DEBUG_ENTRY("execSCHEMA_TRANS_BEGIN_REF");

  if (!(md_trans= get_metadata_transaction_from_message(ndb_message,
                                                        our_trans_id)))
    goto end; /* Ignore faulty messages */

  ic_require(md_trans->state == IC_WAIT_SCHEMA_TRANS_BEGIN_CONF);

  if (ref->error_code == SCHEMA_TRANS_WRONG_MASTER)
  {
    md_trans->node_id= ref->master_node_id;
    DEBUG_PRINT(NDB_MESSAGE_LEVEL, ("Wrong master, resend to master"));
    sendSCHEMA_TRANS_BEGIN_REQ(md_trans);
    goto end;
  }
  else if (ref->error_code == SCHEMA_TRANS_MASTER_BUSY ||
           ref->error_code == SCHEMA_TRANS_MASTER_NR_BUSY)
  {
    /**
      Sleeping as part of message execution is not a good idea, but
      in this case we know that the only activity handled by this
      thread currently is to start a metadata transaction. Not sleeping
      would put an unnecessary pressure on the master node and this
      node.
    */
    ic_microsleep(1000);
    sendSCHEMA_TRANS_BEGIN_REQ(md_trans);
    goto end;
  }
  md_trans_set_external_error(md_trans, ref->error_code);
  md_trans_set_ndb_error(md_trans,
                         ref->error_line,
                         ref->error_node_id,
                         ref->master_node_id);
  md_trans->return_to_api= TRUE;
end:
  DEBUG_RETURN_EMPTY;
}

static void
execSCHEMA_TRANS_BEGIN_CONF_v0(IC_NDB_MESSAGE *ndb_message)
{
  IC_SCHEMA_TRANS_BEGIN_CONF *conf=
    (IC_SCHEMA_TRANS_BEGIN_CONF*)ndb_message->segment_ptr[0];
  guint32 main_message_size= ndb_message->segment_size[0];
  IC_INT_METADATA_TRANSACTION *md_trans;
  /* Word 0 is NDB sender reference, currently no use of this info */
  IC_INT_ALTER_TABLE *alter_table;
  IC_INT_ALTER_TABLESPACE *alter_ts;
  guint32 our_trans_id= conf->my_transaction_id;
  guint32 ndb_trans_ref= conf->ndb_transaction_id;
  DEBUG_ENTRY("execSCHEMA_TRANS_BEGIN_CONF_v0");

  ic_require(main_message_size == SCHEMA_TRANS_BEGIN_CONF_LEN);

  if (!(md_trans= get_metadata_transaction_from_message(ndb_message,
                                                        our_trans_id)))
    goto end; /* Ignore faulty messages */

  ic_require(md_trans->state == IC_WAIT_SCHEMA_TRANS_BEGIN_CONF);
  md_trans->ndb_trans_ref= ndb_trans_ref;

  if ((alter_table= md_trans->current_alter_table))
  {
    switch (alter_table->alter_op_type)
    {
      case IC_CREATE_TABLE_OP:
        sendCREATE_HASH_MAP_REQ(md_trans);
        break;
      case IC_ALTER_TABLE_OP:
        ic_require(FALSE);
        break;
      case IC_DROP_TABLE_OP:
        ic_require(FALSE);
        break;
      case IC_RENAME_TABLE_OP:
        ic_require(FALSE);
        break;
      default:
        ic_require(FALSE);
    }
  }
  else if ((alter_ts= md_trans->current_alter_ts))
  {
    ic_require(FALSE);
  }
  else
    ic_require(FALSE);
end:
  DEBUG_RETURN_EMPTY;
}

static void
sendCREATE_HASH_MAP_REQ(IC_INT_METADATA_TRANSACTION *md_trans)
{
  guint32 our_reference;
  guint32 len;
  int ret_code;
  void *message_ptr;
  IC_INT_APID_CONNECTION *apid_conn= md_trans->apid_conn;
  IC_INT_APID_GLOBAL *apid_global= apid_conn->apid_global;
  IC_CREATE_HASH_MAP_REQ map_req;
  DEBUG_ENTRY("sendCREATE_HASH_MAP_REQ");

  /* Get our NDB reference */
  our_reference= ic_get_ic_reference(apid_global->my_node_id,
                                     apid_conn->thread_id);

  /* Define the message data */
  map_req.my_reference= our_reference;
  map_req.my_data= 0; /* Not used */
  map_req.ndb_transaction_id= md_trans->ndb_trans_ref;
  map_req.my_transaction_id= md_trans->my_trans_ref;
  map_req.flags= CREATE_HASH_MAP_IF_NOT_EXISTS |
                 CREATE_HASH_MAP_DEFAULT;
  map_req.num_buckets= 0;
  map_req.num_partitions= 0;

  md_trans->state= IC_WAIT_CREATE_HASH_MAP_CONF;

  /* Send the message */
  message_ptr= &map_req;
  len= CREATE_HASH_MAP_REQ_LEN;
  if ((ret_code= send_message(apid_conn,
                              CREATE_HASH_MAP_REQ_GSN,
                              1, /* No extra segments */
                              &message_ptr,
                              &len,
                              md_trans->cluster_id,
                              md_trans->node_id,
                              IC_NDB_DICT_MODULE,
                              0)))
  {
    md_trans_set_internal_error(md_trans, ret_code);
  }
  DEBUG_RETURN_EMPTY;
}

static void
execCREATE_HASH_MAP_CONF_v0(IC_NDB_MESSAGE *ndb_message)
{
  guint32 our_trans_id;
  IC_INT_ALTER_TABLE *alter_table;
  IC_INT_METADATA_TRANSACTION *md_trans;
  IC_CREATE_HASH_MAP_CONF *conf=
    (IC_CREATE_HASH_MAP_CONF*)ndb_message->segment_ptr[0];
  DEBUG_ENTRY("execCREATE_HASH_MAP_CONF");

  our_trans_id= conf->my_transaction_id;
  if (!(md_trans= get_metadata_transaction_from_message(ndb_message,
                                                        our_trans_id)))
    goto end; /* Ignore faulty messages */
  ic_require(md_trans->state == IC_WAIT_CREATE_HASH_MAP_CONF);

  /* Set intereresting references to the hash map object */
  alter_table= md_trans->current_alter_table;
  alter_table->hash_map_id= conf->ndb_object_id;
  alter_table->hash_map_version= conf->ndb_object_version;
  sendCREATE_TABLE_REQ(md_trans, alter_table);
end:
  DEBUG_RETURN_EMPTY;
}

static void
sendCREATE_TABLE_REQ(IC_INT_METADATA_TRANSACTION *md_trans,
                     IC_INT_ALTER_TABLE *alter_table)
{
  int ret_code;
  guint32 desc_size;
  guint32 our_reference;
  IC_CREATE_TABLE_REQ begin_req;
  gchar *buf= NULL;
  IC_DYNAMIC_ARRAY *dyn_array;
  guint32 size_array[2];
  void *segment_array[2];
  IC_INT_APID_CONNECTION *apid_conn= md_trans->apid_conn;
  IC_INT_APID_GLOBAL *apid_global= apid_conn->apid_global;
  DEBUG_ENTRY("sendCREATE_TABLE_REQ");

  if (!(dyn_array= fill_create_table_info_properties(alter_table)))
    goto mem_error;

  desc_size= dyn_array->da_ops.ic_get_current_size(dyn_array);
  if (!(buf= ic_malloc(desc_size)))
    goto mem_error;

  /* Get our NDB reference */
  our_reference= ic_get_ic_reference(apid_global->my_node_id,
                                     apid_conn->thread_id);

  begin_req.my_reference= our_reference;
  begin_req.my_data= 0;
  begin_req.flags= 0;
  begin_req.my_transaction_id= md_trans->my_trans_ref;
  begin_req.ndb_transaction_id= md_trans->ndb_trans_ref;

  md_trans->state= IC_WAIT_CREATE_TABLE_CONF;

  size_array[0]= CREATE_TABLE_REQ_LEN;
  segment_array[0]= &begin_req;
  size_array[1]= desc_size/IC_SIZE_UINT32;
  segment_array[1]= buf;

  if ((ret_code= dyn_array->da_ops.ic_read_dynamic_array(dyn_array,
                                                         (guint64)0,
                                                         (guint64)desc_size,
                                                         buf)))
    goto error;
  if ((ret_code= send_fragmented_message(md_trans->apid_conn,
                                         CREATE_TABLE_REQ_GSN,
                                         2,
                                         &segment_array[0],
                                         &size_array[0],
                                         md_trans->cluster_id,
                                         md_trans->node_id,
                                         IC_NDB_DICT_MODULE)))
    goto error;
  ic_free(buf);
  dyn_array->da_ops.ic_free_dynamic_array(dyn_array);
  DEBUG_RETURN_EMPTY;

mem_error:
  ret_code= IC_ERROR_MEM_ALLOC;
error:
  if (buf)
    ic_free(buf);
  if (dyn_array)
    dyn_array->da_ops.ic_free_dynamic_array(dyn_array);

  md_trans_set_internal_error(md_trans, ret_code);
  DEBUG_RETURN_EMPTY;
}

static void
execCREATE_TABLE_CONF_v0(IC_NDB_MESSAGE *ndb_message)
{
  IC_INT_ALTER_TABLE *alter_table;
  IC_CREATE_TABLE_CONF *conf=
    (IC_CREATE_TABLE_CONF*)ndb_message->segment_ptr[0];
  guint32 our_trans_id= conf->my_transaction_id;
  IC_INT_METADATA_TRANSACTION *md_trans;
  DEBUG_ENTRY("execCREATE_TABLE_CONF");

  if (!(md_trans= get_metadata_transaction_from_message(ndb_message,
                                                        our_trans_id)))
    goto end; /* Ignore faulty messages */
  ic_require(md_trans->state == IC_WAIT_CREATE_TABLE_CONF);

  alter_table= md_trans->current_alter_table;
  alter_table->table_id= conf->table_id;
  alter_table->table_version= conf->table_version;
  sendSCHEMA_TRANS_END_REQ(md_trans);
end:
  DEBUG_RETURN_EMPTY;
}

static void
sendSCHEMA_TRANS_END_REQ(IC_INT_METADATA_TRANSACTION *md_trans)
{
  int ret_code;
  guint32 our_reference;
  guint32 len= SCHEMA_TRANS_END_REQ_LEN;
  IC_SCHEMA_TRANS_END_REQ end_req;
  void *message_ptr;
  IC_INT_APID_CONNECTION *apid_conn= md_trans->apid_conn;
  IC_INT_APID_GLOBAL *apid_global= apid_conn->apid_global;
  DEBUG_ENTRY("sendSCHEMA_TRANS_END_REQ");

  /* Get our NDB reference */
  our_reference= ic_get_ic_reference(apid_global->my_node_id,
                                     apid_conn->thread_id);

  /* Set up message data for NDB_MD_TRANS_END_REQ */
  end_req.my_reference= our_reference;
  end_req.my_transaction_id= md_trans->my_trans_ref;
  end_req.request_info= 0;
  end_req.ndb_transaction_id= md_trans->ndb_trans_ref;
  end_req.flags= 0;
  message_ptr= &end_req;

  md_trans->state= IC_WAIT_SCHEMA_TRANS_END_CONF;

  if ((ret_code= send_message(apid_conn,
                              SCHEMA_TRANS_END_REQ_GSN,
                              1, /* No extra segments */
                              &message_ptr,
                              &len,
                              md_trans->cluster_id,
                              md_trans->node_id,
                              IC_NDB_DICT_MODULE,
                              0)))
  {
    md_trans_set_internal_error(md_trans, ret_code);
  }
  DEBUG_RETURN_EMPTY;
}

static void
execSCHEMA_TRANS_END_CONF_v0(IC_NDB_MESSAGE *ndb_message)
{
  IC_SCHEMA_TRANS_END_CONF *conf=
    (IC_SCHEMA_TRANS_END_CONF*)ndb_message->segment_ptr[0];
  guint32 our_trans_id= conf->my_transaction_id;
  IC_INT_METADATA_TRANSACTION *md_trans;
  DEBUG_ENTRY("execSCHEMA_TRANS_END_CONF");

  ic_require(ndb_message->segment_size[0] == SCHEMA_TRANS_END_CONF_LEN);
  if (!(md_trans= get_metadata_transaction_from_message(ndb_message,
                                                        our_trans_id)))
    goto end; /* Ignore faulty messages */
  ic_require(md_trans->state == IC_WAIT_SCHEMA_TRANS_END_CONF);

  md_trans->return_to_api= TRUE;
end:
  DEBUG_RETURN_EMPTY;
}

static void
execCREATE_HASH_MAP_REF_v0(IC_NDB_MESSAGE *ndb_message)
{
  IC_CREATE_HASH_MAP_REF *ref=
    (IC_CREATE_HASH_MAP_REF*)ndb_message->segment_ptr[0];
  guint32 our_trans_id= ref->my_transaction_id;
  IC_INT_METADATA_TRANSACTION *md_trans;
  DEBUG_ENTRY("execCREATE_HASH_MAP_REF");

  if (!(md_trans= get_metadata_transaction_from_message(ndb_message,
                                                        our_trans_id)))
    goto end; /* Ignore faulty messages */
  ic_require(md_trans->state == IC_WAIT_CREATE_HASH_MAP_CONF);
  md_trans_set_external_error(md_trans, ref->error_code);
  md_trans_set_ndb_error(md_trans,
                         ref->error_line,
                         ref->error_node_id,
                         ref->master_node_id);
end:
  DEBUG_RETURN_EMPTY;
}

static void
execCREATE_TABLE_REF_v0(IC_NDB_MESSAGE *ndb_message)
{
  IC_CREATE_TABLE_REF *ref=
    (IC_CREATE_TABLE_REF*)ndb_message->segment_ptr[0];
  guint32 our_trans_id= ref->my_transaction_id;
  IC_INT_METADATA_TRANSACTION *md_trans;
  DEBUG_ENTRY("execCREATE_TABLE_REF");

  if (!(md_trans= get_metadata_transaction_from_message(ndb_message,
                                                        our_trans_id)))
    goto end; /* Ignore faulty messages */
  ic_require(md_trans->state == IC_WAIT_CREATE_TABLE_CONF);
  md_trans_set_external_error(md_trans, ref->error_code);
  md_trans_set_ndb_error(md_trans,
                         ref->error_line,
                         ref->error_node_id,
                         ref->master_node_id);
end:
  DEBUG_RETURN_EMPTY;
}

static void
execSCHEMA_TRANS_END_REF_v0(IC_NDB_MESSAGE *ndb_message)
{
  IC_SCHEMA_TRANS_END_REF *ref=
    (IC_SCHEMA_TRANS_END_REF*)ndb_message->segment_ptr[0];
  guint32 our_trans_id= ref->my_transaction_id;
  IC_INT_METADATA_TRANSACTION *md_trans;
  DEBUG_ENTRY("execSCHEMA_TRANS_END_REF");

  if (!(md_trans= get_metadata_transaction_from_message(ndb_message,
                                                        our_trans_id)))
    goto end; /* Ignore faulty messages */
  ic_require(md_trans->state == IC_WAIT_SCHEMA_TRANS_END_CONF);
  md_trans_set_external_error(md_trans, ref->error_code);
  md_trans_set_ndb_error(md_trans,
                         ref->error_line,
                         ref->error_node_id,
                         ref->master_node_id);
end:
  DEBUG_RETURN_EMPTY;
}

static void
execDROP_TABLE_REF_v0(IC_NDB_MESSAGE *ndb_message)
{
  IC_DROP_TABLE_REF *ref=
    (IC_DROP_TABLE_REF*)ndb_message->segment_ptr[0];
  guint32 our_trans_id= ref->my_transaction_id;
  IC_INT_METADATA_TRANSACTION *md_trans;
  DEBUG_ENTRY("execDROP_TABLE_REF");

  if (!(md_trans= get_metadata_transaction_from_message(ndb_message,
                                                        our_trans_id)))
    goto end; /* Ignore faulty messages */

  md_trans_set_external_error(md_trans, ref->error_code);
  md_trans_set_ndb_error(md_trans,
                         ref->error_line,
                         ref->error_node_id,
                         ref->master_node_id);
end:
  DEBUG_RETURN_EMPTY;
}

static void
execDROP_TABLE_CONF_v0(IC_NDB_MESSAGE *ndb_message)
{
  IC_DROP_TABLE_CONF *conf=
    (IC_DROP_TABLE_CONF*)ndb_message->segment_ptr[0];
  guint32 our_trans_id= conf->my_transaction_id;
  IC_INT_METADATA_TRANSACTION *md_trans;
  DEBUG_ENTRY("execDROP_TABLE_CONF");

  if (!(md_trans= get_metadata_transaction_from_message(ndb_message,
                                                        our_trans_id)))
    goto end; /* Ignore faulty messages */
end:
  DEBUG_RETURN_EMPTY;
}

static void
execALTER_TABLE_REF_v0(IC_NDB_MESSAGE *ndb_message)
{
  IC_ALTER_TABLE_REF *ref=
    (IC_ALTER_TABLE_REF*)ndb_message->segment_ptr[0];
  guint32 our_trans_id= ref->my_transaction_id;
  IC_INT_METADATA_TRANSACTION *md_trans;
  DEBUG_ENTRY("execALTER_TABLE_REF");

  if (!(md_trans= get_metadata_transaction_from_message(ndb_message,
                                                        our_trans_id)))
    goto end; /* Ignore faulty messages */

  md_trans_set_external_error(md_trans, ref->error_code);
  md_trans_set_ndb_error(md_trans,
                         ref->error_line,
                         ref->error_node_id,
                         ref->master_node_id);
end:
  DEBUG_RETURN_EMPTY;
  return;
}

static void
execALTER_TABLE_CONF_v0(IC_NDB_MESSAGE *ndb_message)
{
  IC_ALTER_TABLE_CONF *conf=
    (IC_ALTER_TABLE_CONF*)ndb_message->segment_ptr[0];
  guint32 our_trans_id= conf->my_transaction_id;
  IC_INT_METADATA_TRANSACTION *md_trans;
  DEBUG_ENTRY("execALTER_TABLE_CONF");

  if (!(md_trans= get_metadata_transaction_from_message(ndb_message,
                                                        our_trans_id)))
    goto end; /* Ignore faulty messages */
end:
  DEBUG_RETURN_EMPTY;
  return;
}

static void
execALTER_TABLE_REP_v0(IC_NDB_MESSAGE *ndb_message)
{
  (void)ndb_message;
  return;
}

static void
execCREATE_INDEX_REF_v0(IC_NDB_MESSAGE *ndb_message)
{
  IC_CREATE_INDEX_REF *ref=
    (IC_CREATE_INDEX_REF*)ndb_message->segment_ptr[0];
  guint32 our_trans_id= ref->my_transaction_id;
  IC_INT_METADATA_TRANSACTION *md_trans;
  DEBUG_ENTRY("execCREATE_INDEX_REF");

  if (!(md_trans= get_metadata_transaction_from_message(ndb_message,
                                                        our_trans_id)))
    goto end; /* Ignore faulty messages */
end:
  DEBUG_RETURN_EMPTY;
  return;
}

static void
execCREATE_INDEX_CONF_v0(IC_NDB_MESSAGE *ndb_message)
{
  IC_CREATE_INDEX_CONF *conf=
    (IC_CREATE_INDEX_CONF*)ndb_message->segment_ptr[0];
  guint32 our_trans_id= conf->my_transaction_id;
  IC_INT_METADATA_TRANSACTION *md_trans;
  DEBUG_ENTRY("execCREATE_INDEX_CONF");

  if (!(md_trans= get_metadata_transaction_from_message(ndb_message,
                                                        our_trans_id)))
    goto end; /* Ignore faulty messages */
end:
  DEBUG_RETURN_EMPTY;
  return;
}

static void
execALTER_INDEX_REF_v0(IC_NDB_MESSAGE *ndb_message)
{
  IC_ALTER_INDEX_REF *ref=
    (IC_ALTER_INDEX_REF*)ndb_message->segment_ptr[0];
  guint32 our_trans_id= ref->my_transaction_id;
  IC_INT_METADATA_TRANSACTION *md_trans;
  DEBUG_ENTRY("execALTER_INDEX_REF");

  if (!(md_trans= get_metadata_transaction_from_message(ndb_message,
                                                        our_trans_id)))
    goto end; /* Ignore faulty messages */

  md_trans_set_external_error(md_trans, ref->error_code);
  md_trans_set_ndb_error(md_trans,
                         ref->error_line,
                         ref->error_node_id,
                         ref->master_node_id);
end:
  DEBUG_RETURN_EMPTY;
  return;
}

static void
execALTER_INDEX_CONF_v0(IC_NDB_MESSAGE *ndb_message)
{
  IC_ALTER_INDEX_CONF *conf=
    (IC_ALTER_INDEX_CONF*)ndb_message->segment_ptr[0];
  guint32 our_trans_id= conf->my_transaction_id;
  IC_INT_METADATA_TRANSACTION *md_trans;
  DEBUG_ENTRY("execALTER_INDEX_CONF");

  if (!(md_trans= get_metadata_transaction_from_message(ndb_message,
                                                        our_trans_id)))
    goto end; /* Ignore faulty messages */
end:
  DEBUG_RETURN_EMPTY;
  return;
}

static void
execDROP_INDEX_REF_v0(IC_NDB_MESSAGE *ndb_message)
{
  IC_DROP_INDEX_REF *ref=
    (IC_DROP_INDEX_REF*)ndb_message->segment_ptr[0];
  guint32 our_trans_id= ref->my_transaction_id;
  IC_INT_METADATA_TRANSACTION *md_trans;
  DEBUG_ENTRY("execDROP_INDEX_REF");

  if (!(md_trans= get_metadata_transaction_from_message(ndb_message,
                                                        our_trans_id)))
    goto end; /* Ignore faulty messages */

  md_trans_set_external_error(md_trans, ref->error_code);
  md_trans_set_ndb_error(md_trans,
                         ref->error_line,
                         ref->error_node_id,
                         ref->master_node_id);
end:
  DEBUG_RETURN_EMPTY;
  return;
}

static void
execDROP_INDEX_CONF_v0(IC_NDB_MESSAGE *ndb_message)
{
  IC_DROP_INDEX_CONF *conf=
    (IC_DROP_INDEX_CONF*)ndb_message->segment_ptr[0];
  guint32 our_trans_id= conf->my_transaction_id;
  IC_INT_METADATA_TRANSACTION *md_trans;
  DEBUG_ENTRY("execDROP_INDEX_CONF");

  if (!(md_trans= get_metadata_transaction_from_message(ndb_message,
                                                        our_trans_id)))
    goto end; /* Ignore faulty messages */
end:
  DEBUG_RETURN_EMPTY;
  return;
}

static void
execCREATE_TABLESPACE_REF_v0(IC_NDB_MESSAGE *ndb_message)
{
  guint32 our_trans_id= 0;
  IC_INT_METADATA_TRANSACTION *md_trans;
  DEBUG_ENTRY("execCREATE_TABLESPACE_REF");

  if (!(md_trans= get_metadata_transaction_from_message(ndb_message,
                                                        our_trans_id)))
    goto end; /* Ignore faulty messages */
end:
  DEBUG_RETURN_EMPTY;
  return;
}

static void
execCREATE_TABLESPACE_CONF_v0(IC_NDB_MESSAGE *ndb_message)
{
  guint32 our_trans_id= 0;
  IC_INT_METADATA_TRANSACTION *md_trans;
  DEBUG_ENTRY("execCREATE_TABLESPACE_CONF");

  if (!(md_trans= get_metadata_transaction_from_message(ndb_message,
                                                        our_trans_id)))
    goto end; /* Ignore faulty messages */
end:
  DEBUG_RETURN_EMPTY;
  return;
}

static void
execDROP_TABLESPACE_REF_v0(IC_NDB_MESSAGE *ndb_message)
{
  guint32 our_trans_id= 0;
  IC_INT_METADATA_TRANSACTION *md_trans;
  DEBUG_ENTRY("execDROP_TABLESPACE_REF");

  if (!(md_trans= get_metadata_transaction_from_message(ndb_message,
                                                        our_trans_id)))
    goto end; /* Ignore faulty messages */
end:
  DEBUG_RETURN_EMPTY;
  return;
}

static void
execDROP_TABLESPACE_CONF_v0(IC_NDB_MESSAGE *ndb_message)
{
  guint32 our_trans_id= 0;
  IC_INT_METADATA_TRANSACTION *md_trans;
  DEBUG_ENTRY("execDROP_TABLESPACE_CONF");

  if (!(md_trans= get_metadata_transaction_from_message(ndb_message,
                                                        our_trans_id)))
    goto end; /* Ignore faulty messages */
end:
  DEBUG_RETURN_EMPTY;
  return;
}

static void
execCREATE_TS_FILE_REF_v0(IC_NDB_MESSAGE *ndb_message)
{
  guint32 our_trans_id= 0;
  IC_INT_METADATA_TRANSACTION *md_trans;
  DEBUG_ENTRY("execCREATE_TS_FILE_REF");

  if (!(md_trans= get_metadata_transaction_from_message(ndb_message,
                                                        our_trans_id)))
    goto end; /* Ignore faulty messages */
end:
  DEBUG_RETURN_EMPTY;
  return;
}

static void
execCREATE_TS_FILE_CONF_v0(IC_NDB_MESSAGE *ndb_message)
{
  guint32 our_trans_id= 0;
  IC_INT_METADATA_TRANSACTION *md_trans;
  DEBUG_ENTRY("execCREATE_TS_FILE_CONF");

  if (!(md_trans= get_metadata_transaction_from_message(ndb_message,
                                                        our_trans_id)))
    goto end; /* Ignore faulty messages */
end:
  DEBUG_RETURN_EMPTY;
  return;
}

static void
execDROP_TS_FILE_REF_v0(IC_NDB_MESSAGE *ndb_message)
{
  guint32 our_trans_id= 0;
  IC_INT_METADATA_TRANSACTION *md_trans;
  DEBUG_ENTRY("execDROP_TS_FILE_REF");

  if (!(md_trans= get_metadata_transaction_from_message(ndb_message,
                                                        our_trans_id)))
    goto end; /* Ignore faulty messages */
end:
  DEBUG_RETURN_EMPTY;
  return;
}

static void
execDROP_TS_FILE_CONF_v0(IC_NDB_MESSAGE *ndb_message)
{
  guint32 our_trans_id= 0;
  IC_INT_METADATA_TRANSACTION *md_trans;
  DEBUG_ENTRY("execDROP_TS_FILE_CONF");

  if (!(md_trans= get_metadata_transaction_from_message(ndb_message,
                                                        our_trans_id)))
    goto end; /* Ignore faulty messages */
end:
  DEBUG_RETURN_EMPTY;
  return;
}

static void
execLIST_TABLES_CONF_v0(IC_NDB_MESSAGE *ndb_message)
{
  guint32 our_trans_id= 0;
  IC_INT_METADATA_TRANSACTION *md_trans;
  DEBUG_ENTRY("execLIST_TABLES_CONF");

  if (!(md_trans= get_metadata_transaction_from_message(ndb_message,
                                                        our_trans_id)))
    goto end; /* Ignore faulty messages */
end:
  DEBUG_RETURN_EMPTY;
  return;
}

static void
execGET_TABINFO_REF_v0(IC_NDB_MESSAGE *ndb_message)
{
  IC_GET_TABINFO_REF *ref=
    (IC_GET_TABINFO_REF*)ndb_message->segment_ptr[0];
  guint32 our_trans_id= ref->my_transaction_id;
  IC_INT_METADATA_TRANSACTION *md_trans;
  DEBUG_ENTRY("execGET_TABINFO_REF");

  if (!(md_trans= get_metadata_transaction_from_message(ndb_message,
                                                        our_trans_id)))
    goto end; /* Ignore faulty messages */
  md_trans_set_external_error(md_trans, ref->error_code);
  md_trans->error_object.error_line= ref->error_line;
end:
  DEBUG_RETURN_EMPTY;
  return;
}

static void
execGET_TABINFO_CONF_v0(IC_NDB_MESSAGE *ndb_message)
{
  guint32 our_trans_id= 0;
  IC_INT_METADATA_TRANSACTION *md_trans;
  DEBUG_ENTRY("execGET_TABINFO_CONF");

  if (!(md_trans= get_metadata_transaction_from_message(ndb_message,
                                                        our_trans_id)))
    goto end; /* Ignore faulty messages */
end:
  DEBUG_RETURN_EMPTY;
  return;
}

static void
execGET_TABLE_ID_REF_v0(IC_NDB_MESSAGE *ndb_message)
{
  guint32 our_trans_id= 0;
  IC_INT_METADATA_TRANSACTION *md_trans;
  DEBUG_ENTRY("execGET_TABLE_ID_REF");

  if (!(md_trans= get_metadata_transaction_from_message(ndb_message,
                                                        our_trans_id)))
    goto end; /* Ignore faulty messages */
end:
  DEBUG_RETURN_EMPTY;
  return;
}

static void
execGET_TABLE_ID_CONF_v0(IC_NDB_MESSAGE *ndb_message)
{
  guint32 our_trans_id= 0;
  IC_INT_METADATA_TRANSACTION *md_trans;
  DEBUG_ENTRY("execGET_TABLE_ID_CONF");

  if (!(md_trans= get_metadata_transaction_from_message(ndb_message,
                                                        our_trans_id)))
    goto end; /* Ignore faulty messages */
end:
  DEBUG_RETURN_EMPTY;
  return;
}

static void
execSCHEMA_TRANS_END_REP_v0(IC_NDB_MESSAGE *ndb_message)
{
  guint32 our_trans_id= 0;
  IC_INT_METADATA_TRANSACTION *md_trans;
  DEBUG_ENTRY("execSCHEMA_TRANS_END_REP");

  if (!(md_trans= get_metadata_transaction_from_message(ndb_message,
                                                        our_trans_id)))
    goto end; /* Ignore faulty messages */
end:
  DEBUG_RETURN_EMPTY;
  return;
}

static int
fill_uint32_property(IC_DYNAMIC_ARRAY *dyn_array,
                     guint32 key,
                     guint32 value)
{
  guint32 val[2];

  val[0]= htonl((IC_UINT32_VALUE_TYPE << 16) + key);
  val[1]= htonl(value);
  return dyn_array->da_ops.ic_insert_dynamic_array(dyn_array,
                                     (const gchar*)&val[0],
                                          (guint64)2 * IC_SIZE_UINT32);
}

static int
fill_binary_property(IC_DYNAMIC_ARRAY *dyn_array,
                     guint32 key,
                     guint32 binary_value_len,
                     gchar *binary_value)
{
  guint32 words_len;
  guint32 val[2];
  gchar *binary_val_ptr;
  int ret_code;

  val[0]= htonl((IC_BINARY_VALUE_TYPE << 16) + key);
  val[1]= htonl(binary_value_len);

  if ((ret_code= dyn_array->da_ops.ic_insert_dynamic_array(dyn_array,
                                           (const gchar*)&val[0],
                                                (guint64)2 * IC_SIZE_UINT32)))
    return ret_code;

  if (binary_value_len == 0)
    return 0;

  words_len=(binary_value_len + IC_SIZE_UINT32 - 1)/IC_SIZE_UINT32;
  binary_val_ptr= ic_calloc(IC_SIZE_UINT32 * words_len);
  if (!binary_val_ptr)
    return IC_ERROR_MEM_ALLOC;

  memcpy(binary_val_ptr, binary_value, binary_value_len);
  ret_code= dyn_array->da_ops.ic_insert_dynamic_array(dyn_array,
                                  (const gchar*)binary_val_ptr,
                                       (guint64)IC_SIZE_UINT32 * words_len);
  ic_free(binary_val_ptr);
  return ret_code;
}

static int
fill_string_property(IC_DYNAMIC_ARRAY *dyn_array,
                     guint32 key,
                     gchar *string)
{
  guint32 str_len, str_words_len;
  guint32 val[2];
  gchar *str_ptr;
  int ret_code;

  if (string)
    str_len= strlen(string) + 1;
  else
    str_len= 0;
  val[0]= htonl((IC_STRING_VALUE_TYPE << 16) + key);
  val[1]= htonl(str_len);

  if ((ret_code= dyn_array->da_ops.ic_insert_dynamic_array(dyn_array,
                                        (const gchar*)&val[0],
                                             (guint64)2 * IC_SIZE_UINT32)))
    return ret_code;

  if (str_len == 0)
    return 0;

  str_words_len=(str_len + IC_SIZE_UINT32)/IC_SIZE_UINT32;
  str_ptr= ic_calloc(IC_SIZE_UINT32 * str_words_len);
  if (!str_ptr)
    return IC_ERROR_MEM_ALLOC;

  memcpy(str_ptr, string, str_len);
  ret_code= dyn_array->da_ops.ic_insert_dynamic_array(dyn_array,
                               (const gchar*)str_ptr,
                                    (guint64)IC_SIZE_UINT32 * str_words_len);
  ic_free(str_ptr);
  return ret_code;
}

static guint32
get_num_added_null_cols(IC_INT_ALTER_TABLE *alter_table)
{
  IC_DEFINE_FIELD *def_type;
  guint32 num_nulls= 0;

  FOR_EACH_SLL(def_type, alter_table, add_field)
  {
    if (def_type->is_nullable)
      num_nulls++;
  }
  return num_nulls;
}

static guint32
get_num_added_pkey_cols(IC_INT_ALTER_TABLE *alter_table)
{
  IC_DEFINE_INDEX *def_index;

  FOR_EACH_SLL(def_index, alter_table, add_index)
  {
    if (def_index->type == IC_PRIMARY_KEY)
      return def_index->num_fields;
  }
  return 0;
}

static guint32
get_col_size(IC_DEFINE_FIELD *field)
{
  guint32 col_size= 3; /* 1 byte size is default */
  switch (field->size)
  {
    case 1:
       col_size= 3;
       break;
    case 2:
       col_size= 4;
       break;
    case 3:
    case 4:
       col_size= 5;
       break;
    case 8:
       col_size= 6;
       break;
    case 16:
       col_size= 7;
       break;
    default:
       ic_require(FALSE);
       break;
  }
  return col_size;
}

static int
get_create_table_info_properties(guint32 *property_array,
                                 guint32 length,
                                 IC_INT_TABLE_DEF **table_def,
                                 IC_MEMORY_CONTAINER **ext_mc_ptr)
{
  guint32 index= 0;
  guint32 current_num_column= 0;
  guint32 current_num_null_column= 0;
  guint32 current_num_pkey_column= 0;
  guint32 key;
  guint32 value, val1, type;
  gchar *name_ptr;
  gchar *property_ptr;
  gboolean column_mode= FALSE;
  int ret_code= IC_ERROR_MEM_ALLOC;
  IC_INT_TABLE_DEF *loc_table_def;
  IC_FIELD_DEF *current_field_def;
  IC_MEMORY_CONTAINER *mc_ptr;

  if (!(mc_ptr= ic_create_memory_container(0, 0, FALSE)))
  {
    return IC_ERROR_MEM_ALLOC;
  }
  if (!(loc_table_def= (IC_INT_TABLE_DEF*)
                       mc_ptr->mc_ops.ic_mc_calloc(mc_ptr,
                         sizeof(IC_INT_TABLE_DEF))))
  {
    goto mem_error;
  }

  while ((index + 1) < length)
  {
    val1= ntohl(property_array[index]);
    value= ntohl(property_array[index + 1]);
    index+= 2;

    type= val1 >> 16;
    key= val1 & 0xFFFF;

    if (type == IC_STRING_VALUE_TYPE &&
        type == IC_BINARY_VALUE_TYPE)
    {
      property_ptr= (gchar*)&property_array[index];
      index+= ((value + 3)/4);
      if (index >= length)
        goto protocol_error;
    }
    if (!column_mode)
    {
      if (type == IC_UINT32_VALUE_TYPE)
      {
        switch (key)
        {
          case IC_TABLE_ID_KEY:
          {
            loc_table_def->table_id= value;
            break;
          }
          case IC_TABLE_VERSION_KEY:
          {
            loc_table_def->table_version= value;
            break;
          }
          case IC_TABLE_LOGGED_KEY:
          {
            /* Ignore this property */
            break;
          }
          case IC_NUM_PKEY_COL_KEY:
          {
            loc_table_def->num_key_fields= value;
            if (!(loc_table_def->key_fields=
                ic_mc_create_bitmap(mc_ptr, loc_table_def->num_key_fields)))
              goto mem_error;
            break;
          }
          case IC_NUM_COL_KEY:
          {
            loc_table_def->num_fields= value;
            if (!(loc_table_def->fields= (IC_FIELD_DEF**)
                  mc_ptr->mc_ops.ic_mc_calloc(mc_ptr,
                  loc_table_def->num_fields * sizeof(IC_FIELD_DEF*))))
              goto error;
            if (!(loc_table_def->key_field_id_order= (guint32*)
                mc_ptr->mc_ops.ic_mc_calloc(mc_ptr,
                                            loc_table_def->num_fields *
                                            sizeof(guint32))))
              goto error;
            break;
          }
          case IC_NUM_NULL_COL_KEY:
          {
            loc_table_def->num_null_fields= value;
            break;
          }
          case IC_NUM_VARIABLE_COL_KEY:
          case IC_TABLE_K_VALUE_KEY:
          case IC_MIN_LOAD_FACTOR_KEY:
          case IC_MAX_LOAD_FACTOR_KEY:
          case IC_PKEY_LEN_KEY:
          {
            /* Ignore these properties */
            break;
          }
          case IC_FRAGMENT_TYPE_KEY:
          {
            break;
          }
          case IC_TABLE_TYPE_KEY:
          {
            break;
          }
          case IC_PRIMARY_TABLE_ID_KEY:
          case IC_INDEX_STATE_KEY:
          case IC_INSERT_TRIGGER_ID_KEY:
          case IC_UPDATE_TRIGGER_ID_KEY:
          case IC_DELETE_TRIGGER_ID_KEY:
          case IC_CUSTOM_TRIGGER_ID_KEY:
          case IC_FRM_LEN_KEY:
          {
            /* Ignore these properties */
            break;
          }
          case IC_TABLE_TEMPORARY_KEY:
          {
            break;
          }
          case IC_FORCE_VAR_PART_KEY:
          {
            /* Ignore this property */
            break;
          }
          case IC_FRAGMENT_COUNT_KEY:
          {
            break;
          }
          case IC_FRAGMENT_DATA_LEN_KEY:
          {
            break;
          }
          case IC_TABLESPACE_ID_KEY:
          {
            loc_table_def->tablespace_id= value;
            break;
          }
          case IC_TABLESPACE_VERSION_KEY:
          {
            loc_table_def->tablespace_version= value;
            break;
          }
          case IC_TABLESPACE_DATA_LEN_KEY:
          case IC_RANGE_LIST_DATA_LEN_KEY:
          case IC_REPLICA_LIST_DATA_LEN_KEY:
          case IC_MAX_ROWS_LOW_KEY:
          case IC_MAX_ROWS_HIGH_KEY:
          case IC_DEFAULT_NUM_PARTITIONS_FLAG_KEY:
          case IC_LINEAR_HASH_FLAG_KEY:
          case IC_MIN_ROWS_LOW_KEY:
          case IC_MIN_ROWS_HIGH_KEY:
          case IC_ROW_GCI_FLAG_KEY:
          case IC_ROW_CHECKSUM_FLAG_KEY:
          case IC_SINGLE_USER_MODE_KEY:
          {
            /* Ignore this property */
            break;
          }
          case IC_HASH_MAP_ID_KEY:
          {
            loc_table_def->hash_map_id= value;
            break;
          }
          case IC_HASH_MAP_VERSION_KEY:
          {
            loc_table_def->hash_map_id= value;
            break;
          }
          case IC_TABLE_STORAGE_TYPE_KEY:
          case IC_EXTRA_ROW_GCI_BITS_KEY:
          case IC_EXTRA_ROW_AUTHOR_BITS_KEY:
          {
            /* Ignore this property */
            break;
          }
          default:
          {
            /* Incorrect type, protocol error */
            goto protocol_error;
          }
        }
      }
      else if (type == IC_STRING_VALUE_TYPE)
      {
        switch (key)
        {
          case IC_TABLE_NAME_KEY:
          {
            if (value == 0)
            {
              ret_code= IC_ERROR_MISSING_TABLE_NAME;
              goto error;
            }
            if (!(name_ptr= mc_ptr->mc_ops.ic_mc_alloc(mc_ptr, value + 1)))
              goto mem_error;
            memcpy(name_ptr, property_ptr, value);
            name_ptr[value]= 0;
            loc_table_def->table_name= name_ptr;
            break;
          }
          case IC_PRIMARY_TABLE_KEY:
          {
            break;
          }
          default:
          {
            /* Incorrect type, protocol error */
            goto protocol_error;
          }
        }
      }
      else if (type == IC_BINARY_VALUE_TYPE)
      {
        switch (key)
        {
          case IC_FRM_DATA_KEY:
          case IC_TABLESPACE_DATA_KEY:
          {
            /* Ignore this binary/string property */
            break;
          }
          case IC_FRAGMENT_DATA_KEY:
          {
            break;
          }
          case IC_RANGE_LIST_DATA_KEY:
          {
            break;
          }
          case IC_REPLICA_LIST_DATA_KEY:
          {
            break;
          }
          default:
          {
            /* Incorrect type, protocol error */
            goto protocol_error;
          }
        }
      }
      else
      {
        /* Incorrect type, protocol error */
        goto protocol_error;
      }
    }
    else /* Column mode */
    {
      if (type == IC_UINT32_VALUE_TYPE)
      {
        switch (key)
        {
          case IC_COLUMN_ID_KEY:
          {
            current_field_def->field_id= value;
            break;
          }
          case IC_COLUMN_TYPE_KEY:
          {
            current_field_def->field_type= (IC_FIELD_TYPE)value;
            break;
          }
          case IC_COLUMN_SIZE_KEY:
          {
            current_field_def->field_size= value;
            break;
          }
          case IC_COLUMN_ARRAY_SIZE_KEY:
          {
            current_field_def->field_array_size= value;
            break;
          }
          case IC_COLUMN_PKEY_FLAG_KEY:
          {
            if (value)
              current_num_pkey_column++;
            break;
          }
          case IC_COLUMN_STORAGE_TYPE_KEY:
          {
            break;
          }
          case IC_COLUMN_NULL_FLAG_KEY:
          {
            if (value)
              current_num_null_column++;
            current_field_def->is_nullable= TRUE;
            break;
          }
          case IC_COLUMN_DYNAMIC_FLAG_KEY:
          {
            break;
          }
          case IC_COLUMN_DISTRIBUTION_KEY_FLAG_KEY:
          {
            break;
          }
          case IC_COLUMN_EXT_TYPE_KEY:
          {
            break;
          }
          case IC_COLUMN_EXT_PRECISION_KEY:
          {
            break;
          }
          case IC_COLUMN_EXT_SCALE_KEY:
          {
            break;
          }
          case IC_COLUMN_EXT_LEN_KEY:
          {
            break;
          }
          case IC_COLUMN_AUTO_INCREMENT_FLAG_KEY:
          {
            break;
          }
          case IC_COLUMN_ARRAY_TYPE_KEY:
          {
            break;
          }
          case IC_COLUMN_DEFAULT_VALUE_LEN_KEY:
          {
            break;
          }
          case IC_COLUMN_END_KEY:
          {
            break;
          }
          default:
          {
            /* Incorrect type, protocol error */
            goto protocol_error;
          }
        }
      }
      else if (type == IC_STRING_VALUE_TYPE)
      {
        switch (key)
        {
          case IC_COLUMN_NAME_KEY:
          {
            if (value == 0)
            {
              ret_code= IC_ERROR_MISSING_COLUMN_NAME;
              goto error;
            }
            if (!(name_ptr= mc_ptr->mc_ops.ic_mc_alloc(mc_ptr, value + 1)))
              goto mem_error;
            memcpy(name_ptr, property_ptr, value);
            name_ptr[value]= 0;
            if (!(loc_table_def->fields[current_num_column]= (IC_FIELD_DEF*)
                mc_ptr->mc_ops.ic_mc_calloc(mc_ptr, sizeof(IC_FIELD_DEF))))
              goto mem_error;
            current_field_def= loc_table_def->fields[current_num_column];
            current_field_def->field_name= name_ptr;
            current_num_column++;
            break;
          }
          default:
          {
            /* Incorrect type, protocol error */
            goto protocol_error;
          }
        }
      }
      else if (type == IC_BINARY_VALUE_TYPE)
      {
        switch (key)
        {
          current_field_def->default_value_len= value;
          case IC_COLUMN_DEFAULT_VALUE_KEY:
          {
            if (value == 0)
            {
              current_field_def->default_value= NULL;
            }
            else
            {
              if (!(current_field_def->default_value= (gchar*)
                    mc_ptr->mc_ops.ic_mc_alloc(mc_ptr, value + 1)))
                goto mem_error;
              
              current_field_def->default_value_len= value;
              memcpy(current_field_def->default_value,
                     property_ptr,
                     value);
              current_field_def->default_value[value]= 0;
            }
            break;
          }
          default:
          {
            /* Incorrect type, protocol error */
            goto protocol_error;
          }
        }
      }
      else
      {
        /* Incorrect type, protocol error */
        goto protocol_error;
      }
    }
  }
  if (!(current_num_column &&
        current_num_column == loc_table_def->num_fields &&
        current_num_pkey_column == loc_table_def->num_key_fields &&
        current_num_null_column == loc_table_def->num_null_fields))
    goto protocol_error;
  *table_def= loc_table_def;
  *ext_mc_ptr= mc_ptr;
  return 0;
error:
  mc_ptr->mc_ops.ic_mc_free(mc_ptr);
  return ret_code;

protocol_error:
  ret_code= IC_PROTOCOL_ERROR;
  goto error;

mem_error:
  ret_code= IC_ERROR_MEM_ALLOC;
  goto error;
}

static IC_DYNAMIC_ARRAY*
fill_create_table_info_properties(IC_INT_ALTER_TABLE *alter_table)
{
  guint32 num_cols, num_null_cols, num_pkey_cols;
  guint32 col_size;
  int ret_code;
  IC_DYNAMIC_ARRAY *dyn_array;
  IC_DEFINE_FIELD *next_field;

  if (!(dyn_array= ic_create_simple_dynamic_array()))
    goto error;

  num_cols= alter_table->num_fields;
  num_null_cols= get_num_added_null_cols(alter_table);
  num_pkey_cols= get_num_added_pkey_cols(alter_table);

  if ((ret_code= fill_string_property(dyn_array,
                                      IC_TABLE_NAME_KEY,
                                      alter_table->table_name)) ||
      (ret_code= fill_uint32_property(dyn_array,
                                      IC_TABLE_VERSION_KEY,
                                      IC_MINUS_ONE)) ||
      (ret_code= fill_uint32_property(dyn_array,
                                      IC_TABLE_LOGGED_KEY,
                             (guint32)alter_table->is_table_logged)) ||
      (ret_code= fill_uint32_property(dyn_array,
                                      IC_NUM_PKEY_COL_KEY,
                                      num_pkey_cols)) ||
      (ret_code= fill_uint32_property(dyn_array,
                                      IC_NUM_COL_KEY,
                                      num_cols)) ||
      (ret_code= fill_uint32_property(dyn_array,
                                      IC_NUM_NULL_COL_KEY,
                                      num_null_cols)) ||
      /* Number of variable columns always defined as 0 here */
      (ret_code= fill_uint32_property(dyn_array,
                                      IC_NUM_VARIABLE_COL_KEY,
                                      0)) ||
      /* Table K value always defined as default == 6 */
      (ret_code= fill_uint32_property(dyn_array,
                                      IC_TABLE_K_VALUE_KEY,
                                      IC_TABLE_K_VALUE_DEFAULT)) ||
      /* Min Load Factor always defined as default == 78 */
      (ret_code= fill_uint32_property(dyn_array,
                                      IC_MIN_LOAD_FACTOR_KEY,
                                      IC_MIN_LOAD_FACTOR_DEFAULT)) ||
      /* Max Load Factor always defined as our default == 90 */
      (ret_code= fill_uint32_property(dyn_array,
                                      IC_MAX_LOAD_FACTOR_KEY,
                                      IC_MAX_LOAD_FACTOR_OUR_DEFAULT)) ||
      /* Ok to send primary key length 0 here */
      (ret_code= fill_uint32_property(dyn_array,
                                      IC_PKEY_LEN_KEY,
                                      0)) ||
      /* Fragment Type always hashmap partition */
      (ret_code= fill_uint32_property(dyn_array,
                                      IC_FRAGMENT_TYPE_KEY,
                                      IC_FRAGMENT_TYPE_DEFAULT)) ||
      /* Table Type always user table */
      (ret_code= fill_uint32_property(dyn_array,
                                      IC_TABLE_TYPE_KEY,
                                      IC_TABLE_TYPE_DEFAULT)) ||
      /* Primary Table only used in secondary indexes */
      (ret_code= fill_string_property(dyn_array,
                                      IC_PRIMARY_TABLE_KEY,
                                      NULL)) ||
      /* Primary Table Id only used in secondary indexes */
      (ret_code= fill_uint32_property(dyn_array,
                                      IC_PRIMARY_TABLE_ID_KEY,
                                      IC_RNIL)) ||
      (ret_code= fill_uint32_property(dyn_array,
                                      IC_INDEX_STATE_KEY,
                                      IC_MINUS_ONE)) ||
      (ret_code= fill_uint32_property(dyn_array,
                                      IC_INSERT_TRIGGER_ID_KEY,
                                      IC_RNIL)) ||
      (ret_code= fill_uint32_property(dyn_array,
                                      IC_UPDATE_TRIGGER_ID_KEY,
                                      IC_RNIL)) ||
      (ret_code= fill_uint32_property(dyn_array,
                                      IC_DELETE_TRIGGER_ID_KEY,
                                      IC_RNIL)) ||
      (ret_code= fill_uint32_property(dyn_array,
                                      IC_CUSTOM_TRIGGER_ID_KEY,
                                      IC_RNIL)) ||
      (ret_code= fill_uint32_property(dyn_array,
                                      IC_FRM_LEN_KEY,
                                      0)) ||
      (ret_code= fill_binary_property(dyn_array,
                                      IC_FRM_DATA_KEY,
                                      0,
                                      NULL)) ||
      (ret_code= fill_uint32_property(dyn_array,
                                      IC_TABLE_TEMPORARY_KEY,
                             (guint32)alter_table->is_table_temporary)) ||
      (ret_code= fill_uint32_property(dyn_array,
                                      IC_FORCE_VAR_PART_KEY,
                                      0)) ||
      (ret_code= fill_uint32_property(dyn_array,
                                      IC_FRAGMENT_COUNT_KEY,
                                      0)) ||
      (ret_code= fill_uint32_property(dyn_array,
                                      IC_FRAGMENT_DATA_LEN_KEY,
                                      0)) ||
      (ret_code= fill_binary_property(dyn_array,
                                      IC_FRAGMENT_DATA_KEY,
                                      0,
                                      NULL)) ||
      (ret_code= fill_uint32_property(dyn_array,
                                      IC_TABLESPACE_ID_KEY,
                                      alter_table->tablespace_id)) ||
      (ret_code= fill_uint32_property(dyn_array,
                                      IC_TABLESPACE_VERSION_KEY,
                                      alter_table->tablespace_version)) ||
      /* TablespaceData/TablespaceDataLen not used here */
      (ret_code= fill_uint32_property(dyn_array,
                                      IC_TABLESPACE_DATA_LEN_KEY,
                                      0)) ||
      (ret_code= fill_binary_property(dyn_array,
                                      IC_TABLESPACE_DATA_KEY,
                                      0,
                                      NULL)) ||
      /* RangeListData/RangeListDataLen not used here */
      (ret_code= fill_uint32_property(dyn_array,
                                      IC_RANGE_LIST_DATA_LEN_KEY,
                                      0)) ||
      (ret_code= fill_binary_property(dyn_array,
                                      IC_RANGE_LIST_DATA_KEY,
                                      0,
                                      NULL)) ||
      /* ReplicaData/ReplicaDataLen not used here */
      (ret_code= fill_uint32_property(dyn_array,
                                      IC_REPLICA_LIST_DATA_LEN_KEY,
                                      0)) ||
      (ret_code= fill_binary_property(dyn_array,
                                      IC_REPLICA_LIST_DATA_KEY,
                                      0,
                                      NULL)) ||
      (ret_code= fill_uint32_property(dyn_array,
                                      IC_MAX_ROWS_LOW_KEY,
                                      0)) ||
      (ret_code= fill_uint32_property(dyn_array,
                                      IC_MAX_ROWS_HIGH_KEY,
                                      0)) ||
      /* Always use Default Num Partitions Flag set */
      (ret_code= fill_uint32_property(dyn_array,
                                      IC_DEFAULT_NUM_PARTITIONS_FLAG_KEY,
                                  IC_DEFAULT_NUM_PARTITIONS_FLAG_DEFAULT)) ||
      /* Always use Linear Hash Flag set */
      (ret_code= fill_uint32_property(dyn_array,
                                      IC_LINEAR_HASH_FLAG_KEY,
                                      IC_LINEAR_HASH_FLAG_DEFAULT)) ||
      (ret_code= fill_uint32_property(dyn_array,
                                      IC_MIN_ROWS_LOW_KEY,
                                      0)) ||
      (ret_code= fill_uint32_property(dyn_array,
                                      IC_MIN_ROWS_HIGH_KEY,
                                      0)) ||
      (ret_code= fill_uint32_property(dyn_array,
                                      IC_ROW_GCI_FLAG_KEY,
                                      IC_ROW_GCI_FLAG_DEFAULT)) ||
      (ret_code= fill_uint32_property(dyn_array,
                                      IC_ROW_CHECKSUM_FLAG_KEY,
                                      IC_ROW_CHECKSUM_FLAG_DEFAULT)) ||
      /* SingleUserMode not used */
      (ret_code= fill_uint32_property(dyn_array,
                                      IC_SINGLE_USER_MODE_KEY,
                                      IC_SINGLE_USER_MODE_DEFAULT)) ||
      (ret_code= fill_uint32_property(dyn_array,
                                      IC_HASH_MAP_ID_KEY,
                                      alter_table->hash_map_id)) ||
      (ret_code= fill_uint32_property(dyn_array,
                                      IC_HASH_MAP_VERSION_KEY,
                                      alter_table->hash_map_version)) ||
      (ret_code= fill_uint32_property(dyn_array,
                                      IC_TABLE_STORAGE_TYPE_KEY,
                             (guint32)alter_table->is_table_disk_stored)) ||
      /* ExtraRowGciBits not used */
      (ret_code= fill_uint32_property(dyn_array,
                                      IC_EXTRA_ROW_GCI_BITS_KEY,
                                      0)) ||
      /* ExtraRowAuthorBits not used */
      (ret_code= fill_uint32_property(dyn_array,
                                      IC_EXTRA_ROW_AUTHOR_BITS_KEY,
                                      0)))
    goto error;

  next_field= alter_table->first_add_field;
  do
  {
    col_size= get_col_size(next_field);

    if ((ret_code= fill_string_property(dyn_array,
                                        IC_COLUMN_NAME_KEY,
                                        next_field->name)) ||
        (ret_code= fill_uint32_property(dyn_array,
                                        IC_COLUMN_ID_KEY,
                                        IC_MINUS_ONE)) ||
        (ret_code= fill_uint32_property(dyn_array,
                                        IC_COLUMN_TYPE_KEY,
                                        IC_MINUS_ONE)) ||
        /*
           Field size is more or less ignored, it's prescribed by the
           external type which is used to set the real field size.
           We do however send the correct field size anyways.
        */
        (ret_code= fill_uint32_property(dyn_array,
                                        IC_COLUMN_SIZE_KEY,
                                        col_size)) ||
        /*
          Array size is set by a combination of external type and external
          length. It's mostly ignored but we still set it to a correct
          value.
        */
        (ret_code= fill_uint32_property(dyn_array,
                                        IC_COLUMN_ARRAY_SIZE_KEY,
                                        next_field->array_size)) ||
        (ret_code= fill_uint32_property(dyn_array,
                                        IC_COLUMN_PKEY_FLAG_KEY,
                               (guint32)next_field->is_part_of_pkey)) ||
        (ret_code= fill_uint32_property(dyn_array,
                                        IC_COLUMN_STORAGE_TYPE_KEY,
                               (guint32)next_field->is_field_disk_stored)) ||
        (ret_code= fill_uint32_property(dyn_array,
                                        IC_COLUMN_NULL_FLAG_KEY,
                               (guint32)next_field->is_nullable)) ||
        (ret_code= fill_uint32_property(dyn_array,
                                        IC_COLUMN_DYNAMIC_FLAG_KEY,
                                        IC_COLUMN_DYNAMIC_FLAG_DEFAULT)) ||
        (ret_code= fill_uint32_property(dyn_array,
                                        IC_COLUMN_DISTRIBUTION_KEY_FLAG_KEY,
                                   IC_COLUMN_DISTRIBUTION_KEY_FLAG_DEFAULT)) ||
        (ret_code= fill_uint32_property(dyn_array,
                                        IC_COLUMN_EXT_TYPE_KEY,
                                        (guint32)next_field->type)) ||
        /*
           Upper 16 bits of external precision contains number of
           character set used for this field.
        */
        (ret_code= fill_uint32_property(dyn_array,
                                        IC_COLUMN_EXT_PRECISION_KEY,
                                        0)) ||
        (ret_code= fill_uint32_property(dyn_array,
                                        IC_COLUMN_EXT_SCALE_KEY,
                                        0)) ||
        (ret_code= fill_uint32_property(dyn_array,
                                        IC_COLUMN_EXT_LEN_KEY,
                                        next_field->array_size)) ||
        (ret_code= fill_uint32_property(dyn_array,
                                        IC_COLUMN_AUTO_INCREMENT_FLAG_KEY,
                                  IC_COLUMN_AUTO_INCREMENT_FLAG_DEFAULT)) ||
        (ret_code= fill_uint32_property(dyn_array,
                                        IC_COLUMN_ARRAY_TYPE_KEY,
                                        IC_COLUMN_ARRAY_TYPE_DEFAULT)) ||
        (ret_code= fill_uint32_property(dyn_array,
                                        IC_COLUMN_DEFAULT_VALUE_LEN_KEY,
                                        next_field->default_value_len)) ||
        (ret_code= fill_binary_property(dyn_array,
                                        IC_COLUMN_DEFAULT_VALUE_KEY,
                                        next_field->default_value_len,
                                        next_field->default_value)) ||
        (ret_code= fill_uint32_property(dyn_array,
                                        IC_COLUMN_END_KEY,
                                        IC_COLUMN_END_DEFAULT)))
      goto error;

    next_field= next_field->next_add_field;
  } while (next_field);

  if ((ret_code= fill_uint32_property(dyn_array,
                                      IC_TABLE_END_KEY,
                                      IC_TABLE_END_DEFAULT)))
    goto error;

  return dyn_array;

error:
  if (dyn_array)
    dyn_array->da_ops.ic_free_dynamic_array(dyn_array);
  return NULL;
}
