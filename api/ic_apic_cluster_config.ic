/* Copyight (C) 2020, 2020 iClaustron AB

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; version 2 of the License.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
#include "ic_apic_cluster_config_int.h"


static guint32
find_config_entry_uint32(guint32 section_start,
                         guint32 key, 
                         guint32 *key_value,
                         guint32 *config_value)
{
  guint32 total_entries = g_ntohl(key_value[section_start + 1]);
  guint32 loop_next_index = section_start + 3;
  DEBUG_PRINT(FIND_NODE_CONFIG_LEVEL,
    ("start of current section %u, total entries in current section %u",
     section_start, total_entries));
  while (total_entries > 0)
  {
    guint32 first_word = g_ntohl(key_value[loop_next_index]);
    guint32 key_type = first_word >> IC_CL_KEY_SHIFT;
    guint32 config_id = first_word & IC_CL_NEW_KEY_MASK;
    DEBUG_PRINT(FIND_NODE_CONFIG_LEVEL,
    ("key type %u configuration id %u", key_type, config_id));
    switch (key_type)
    {
      case 1:
      {
        if (config_id == key)
        {
          *config_value = g_ntohl(key_value[loop_next_index + 1]);
          return 0;
        }
        loop_next_index += 2;
        break;
      }
      case 2:
      {
        loop_next_index += 3;
        break;
      }
      case 4:
      {
        guint32 str_len = g_ntohl(key_value[loop_next_index + 1]);
        guint32 word_count = (str_len + 3)/4;
        loop_next_index += (word_count + 2);
        break;
      }
      default:
      {
        ic_require(FALSE);
        return 1;
      }
    }
    total_entries--;
  }
  return 1; 
  
}
static guint32
find_config_entry_uint64(guint32 section_start,
                         guint32 key,
                         guint32 *key_value,
                         guint64 *config_value)
{
  guint32 total_entries = g_ntohl(key_value[section_start + 1]);
  guint32 loop_next_index = section_start + 3;
  DEBUG_PRINT(FIND_NODE_CONFIG_LEVEL,
    ("start of current section %u, total entries in current section %u",
     section_start, total_entries));
  while (total_entries > 0)
  {
    guint32 first_word = g_ntohl(key_value[loop_next_index]);
    guint32 key_type = first_word >> IC_CL_KEY_SHIFT;
    guint32 config_id = first_word & IC_CL_NEW_KEY_MASK;
    DEBUG_PRINT(FIND_NODE_CONFIG_LEVEL,
    ("key type %u configuration id %u", key_type, config_id));
    switch (key_type)
    {
      case 1:
      {
        loop_next_index += 2;
        break;
      }
      case 2:
      {
        if (config_id == key)
        {
          guint64 val_high = g_ntohl(key_value[loop_next_index + 1]);
          guint64 val_low = g_ntohl(key_value[loop_next_index + 2]);
          guint64 val = val_low + (val_high << 32);
          *config_value = val;
          return 0;
        }
        loop_next_index += 3;
        break;
      }
      case 4:
      {
        guint32 str_len = g_ntohl(key_value[loop_next_index + 1]);
        guint32 word_count = (str_len + 3)/4;
        loop_next_index += (word_count + 2);
        break;
      }
      default:
      {
        ic_require(FALSE);
        return 1;
      }
    }
    total_entries--;
  }
  return 1; 
}
static guint32
find_config_entry_string(guint32 section_start,
                         guint32 key,
                         guint32 *key_value,
                         IC_STRING *config_value)
{
  guint32 total_entries = g_ntohl(key_value[section_start + 1]);
  guint32 loop_next_index = section_start + 3;
  DEBUG_PRINT(FIND_NODE_CONFIG_LEVEL,
    ("start of current section %u, total entries in current section %u",
     section_start, total_entries));

  while (total_entries > 0)
  {
    guint32 first_word = g_ntohl(key_value[loop_next_index]);
    guint32 key_type = first_word >> IC_CL_KEY_SHIFT;
    guint32 config_id = first_word & IC_CL_NEW_KEY_MASK;
    DEBUG_PRINT(FIND_NODE_CONFIG_LEVEL,
    ("key type %u configuration id %u", key_type, config_id));
    switch (key_type)
    {
      case 1:
      {
        loop_next_index += 2;
        break;
      }
      case 2:
      {
        loop_next_index += 3;
        break;
      }
      case 4:
      {
        guint32 str_len = g_ntohl(key_value[loop_next_index + 1]);
        guint32 word_count = (str_len + 3)/4;
        loop_next_index += (word_count + 2);
        if (config_id == key)
        {
          IC_INIT_STRING(config_value,
                         (gchar*)&key_value[loop_next_index +2],
                         str_len -1,
                         TRUE);
          return 0; 
        }
        break;
      }
      default:
      {
        ic_require(FALSE);
        return 1;
      }
    }
    total_entries--;
  }
  return IC_ERROR_NO_CONF_ENTRY_FOUND; 
}
static int
get_def_node_section(IC_INT_CLUSTER_CONFIG *cluster_config,
                     guint8 node_type,
                     guint32 *return_value)
{
  switch (node_type)
  {
    case 1:
    {
      *return_value = cluster_config-> section_def_dn_index;
      break;
    }
    case 2:
    {
      *return_value = cluster_config-> section_def_api_index;
      break;
    }
    case 3:
    {
      *return_value = cluster_config-> section_def_mgm_index;
      break;
    }
    default:
    {
      return IC_ERROR_NO_SUCH_NODE_TYPE;
    }
  }
  return 0;
}

                     
static int
get_node_config_uint32(IC_CLUSTER_CONFIG *ext_cluster_config,
                       guint32 *return_value,
                       guint32 node_id,
                       guint32 key)
{
  IC_INT_CLUSTER_CONFIG *cluster_config =
    (IC_INT_CLUSTER_CONFIG*)ext_cluster_config;
  
  guint32 return_code = find_config_entry_uint32(
                        cluster_config->node_section_ptrs[node_id],
                        key,
                        cluster_config->key_value,
                        return_value);
  if (return_code == 0)
  {
    return return_code;
  }
  guint32 *section_start;                          
  guint32 ret_value = get_def_node_section(
                              cluster_config,
                              cluster_config->node_type_array[node_id],
                              *section_start);
  if (ret_value != 0)
  {
    // handle error
    return IC_ERROR_NO_DEF_NODE_SECT_FOUND;
  }
  return_code = find_config_entry_uint32(section_start,
                                          key,
                                          cluster_config->key_value,
                                          return_value);
  return return_code;
}


static int
get_node_config_uint64(IC_CLUSTER_CONFIG *ext_cluster_config,
                       guint64 *return_value,
                       guint32 node_id,
                       guint32 key)
{
  IC_INT_CLUSTER_CONFIG *cluster_config =
    (IC_INT_CLUSTER_CONFIG*)ext_cluster_config;
  guint32 return_code = find_config_entry_uint64(
                             cluster_config->node_section_ptrs[node_id],
                             key,
                             cluster_config->key_value,
                             return_value);
  if (return_code == 0)
  {
    return return_code;
  }
  guint32 *section_start;                          
  guint32 ret_value = get_def_node_section(
                              cluster_config,
                              cluster_config->node_type_array[node_id],
                              *section_start);
  if (ret_value != 0)
  {
    // handle error
    return IC_ERROR_NO_DEF_NODE_SECT_FOUND;
  }
  return_code = find_config_entry_uint64(section_start,
                                          key,
                                          cluster_config->key_value,
                                          return_value);
  return return_code;
}
static int
get_node_config_str(IC_CLUSTER_CONFIG *ext_cluster_config,
                    IC_STRING *return_value,
                    guint32 node_id,
                    guint32 key)
{
  IC_INT_CLUSTER_CONFIG *cluster_config =
    (IC_INT_CLUSTER_CONFIG*)ext_cluster_config;
  guint32 return_code = find_config_entry_string(
                                  cluster_config->node_section_ptrs[node_id],
                                  key,
                                  cluster_config->key_value,
                                  return_value);
  if (return_code == 0)
  {
    return return_code;
  }
  guint32 *section_start;                          
  guint32 ret_value = get_def_node_section(
                              cluster_config,
                              cluster_config->node_type_array[node_id],
                              *section_start);
  if (ret_value != 0)
  {
    // handle error
    return IC_ERROR_NO_DEF_NODE_SECT_FOUND;
  }
  return_code = find_config_entry_string(section_start,
                                         key,
                                         cluster_config->key_value,
                                         return_value);
  return return_code;
}
static int
get_comm_config_uint32(IC_CLUSTER_CONFIG *ext_cluster_config,
                       guint32 *return_value,
                       guint32 node_id,
                       guint32 key)
{
  IC_INT_CLUSTER_CONFIG *cluster_config =
    (IC_INT_CLUSTER_CONFIG*)ext_cluster_config;
}
static int
get_comm_config_uint64(IC_CLUSTER_CONFIG *ext_cluster_config,
                       guint64 *return_value,
                       guint32 node_id,
                       guint32 key)
{
  IC_INT_CLUSTER_CONFIG *cluster_config =
    (IC_INT_CLUSTER_CONFIG*)ext_cluster_config;
}
static int
get_comm_config_str(IC_CLUSTER_CONFIG *ext_cluster_config,
                    IC_STRING *return_value,
                    guint32 node_id,
                    guint32 key)
{
  IC_INT_CLUSTER_CONFIG *cluster_config =
    (IC_INT_CLUSTER_CONFIG*)ext_cluster_config;
}

static guint32
find_nodeid(guint32 next_index, 
            guint32 *key_value,
            guint32 *node_id, 
            guint32 *node_type)
{
  guint32 next_len = g_ntohl(key_value[next_index]);
  guint32 current_next_index = next_index;
  next_index += next_len;
  guint32 total_entries = g_ntohl(key_value[current_next_index + 1]);
  *node_type = g_ntohl(key_value[current_next_index + 2]);
  guint32 loop_next_index = current_next_index + 3;
  DEBUG_PRINT(FIND_NODE_CONFIG_LEVEL,
    ("total entries %u node type %x",
     total_entries, *node_type));

  while (total_entries > 0)
  {
    guint32 first_word = g_ntohl(key_value[loop_next_index]);
    guint32 key_type = first_word >> IC_CL_KEY_SHIFT;
    guint32 key = first_word & IC_CL_NEW_KEY_MASK;
    DEBUG_PRINT(FIND_NODE_CONFIG_LEVEL,
    ("key %u key type %u", key, key_type));

    switch (key_type)
    {
      case 1:
      {
        if (key == IC_NODE_ID)
        {
          *node_id = g_ntohl(key_value[loop_next_index + 1]);
          return next_index;
        }
        loop_next_index += 2;
      }
      case 2:
      {
        loop_next_index += 3;
      }
      case 4:
      {
        guint32 str_len = g_ntohl(key_value[loop_next_index + 1]);
        guint32 word_count = (str_len + 3)/4;
        loop_next_index += (word_count + 2);
      }
      default:
      {
        ic_require(FALSE);
        return 1;
      }
    }
    total_entries--;
  }
  return 0; 
  
}

static guint32
check_section(guint32 *key_value,
              guint32 section_start,
              gboolean is_system_section)
{
  IC_CONFIG_ENTRY *conf_obj;
  guint32 total_entries = g_ntohl(key_value[section_start + 1]);
  guint32 loop_next_index = section_start + 3;
  DEBUG_PRINT(FIND_NODE_CONFIG_LEVEL,
    ("start of current section %u, total entries in current section %u",
     section_start, total_entries));
  while (total_entries > 0)
  {
    guint32 first_word= g_ntohl(key_value[loop_next_index]);
    guint32 key_type= first_word >> IC_CL_KEY_SHIFT;
    guint32 key= first_word & IC_CL_NEW_KEY_MASK;
    if (is_system_section)
    {
      key += SYSTEM_SECTION_ADJUSTMENT;
    }
    conf_obj= get_conf_entry(key);
    DEBUG_PRINT(FIND_NODE_CONFIG_LEVEL,
    ("config id %u", key));
    if (conf_obj == NULL)
    {
      return 1;
    }
    switch (key_type)
    {
      case 1:
      { 
        DEBUG_PRINT(FIND_NODE_CONFIG_LEVEL,
        ("config entry name %s, ndb entry name %s, config types %u",
         conf_obj->config_entry_name.str,
         conf_obj->ndb_entry_name.str,
         conf_obj->config_types));
        loop_next_index += 2; 
        break;
      }
      case 4:
      {
        DEBUG_PRINT(FIND_NODE_CONFIG_LEVEL,
        ("config entry name %s, ndb entry name %s, config types %u,"
          "max value %llu, min value %llu",
         conf_obj->config_entry_name.str,
         conf_obj->ndb_entry_name.str,
         conf_obj->config_types,
         conf_obj->max_value,
         conf_obj->min_value));
        loop_next_index += 3;
        break;
      }
      case 2:
      {
        guint32 str_len = g_ntohl(key_value[loop_next_index + 1]);
        guint32 word_count = (str_len + 3)/4;
        loop_next_index += (word_count + 2);
        DEBUG_PRINT(FIND_NODE_CONFIG_LEVEL,
        ("config entry name %s, ndb entry name %s, word count %u",
         conf_obj->config_entry_name.str,
         conf_obj->ndb_entry_name.str,
         word_count));
        break;
      }
      default:
      {
        ic_require(FALSE);
        return 1;
      }
    }
    total_entries--;
  }
  return 0; ;
}


IC_CLUSTER_CONFIG*
ic_create_network_cluster_config(guint32 *key_value,
                                 guint32 len,
                                 guint32 cluster_id,
                                 int *error_code)
{
  guint32 ret;
  IC_INT_CLUSTER_CONFIG *conf;
  guint32 *my_key_value;
  DEBUG_ENTRY("create network cluster config");
  if (!(conf= (IC_INT_CLUSTER_CONFIG*)ic_calloc(sizeof(*conf))))
  {
    *error_code = IC_ERROR_MEM_ALLOC;
    DEBUG_RETURN_PTR(NULL);
  }
  if (!(my_key_value = (guint32*)ic_calloc(len*4)))
  {
    ic_free(conf);
    *error_code = IC_ERROR_MEM_ALLOC;
    DEBUG_RETURN_PTR(NULL);
  }
  memcpy(my_key_value, key_value, 4*len);
  conf-> key_value = my_key_value;
  conf-> len = len;
  conf-> cluster_id = cluster_id;
  DEBUG_PRINT(CONFIG_PROTO_LEVEL,
    ("length %u cluster_id %u", len, cluster_id));
 
  conf-> section_def_dn_index = 7;
  DEBUG_PRINT(CONFIG_PROTO_LEVEL,
    ("start of default datanode section index %u",
     conf->section_def_dn_index));
  if ((ret= check_section(key_value, 
                          conf-> section_def_dn_index,
                          FALSE)) !=0)
  {
    return ret;
  }
  guint32 next_len = g_ntohl(key_value[7]);
  guint32 next_index = 7 + next_len;


  conf-> section_def_api_index = next_index;
  DEBUG_PRINT(CONFIG_PROTO_LEVEL,
    ("start of default api node section index  %u", 
     conf->section_def_api_index));
  if ((ret= check_section(key_value,
                          conf-> section_def_api_index,
                          FALSE)) !=0)
  {
    return ret;
  }
  next_len = g_ntohl(key_value[next_index]);
  next_index += next_len;


  conf-> section_def_mgm_index = next_index;
  DEBUG_PRINT(CONFIG_PROTO_LEVEL,
    ("start of default mgm node section index %u", 
     conf->section_def_mgm_index));
  if ((ret= check_section(key_value,
                          conf-> section_def_mgm_index,
                          FALSE)) !=0)
  {
    return ret;
  }
  next_len = g_ntohl(key_value[next_index]);
  next_index += next_len;


  conf-> section_def_tcp_index = next_index; 
  DEBUG_PRINT(CONFIG_PROTO_LEVEL,
    ("start of default tcp section index %u", 
     conf->section_def_tcp_index));
  if ((ret= check_section(key_value,
                          conf-> section_def_tcp_index,
                          FALSE)) !=0)
  {
    return ret;
  }
  next_len = g_ntohl(key_value[next_index]);
  next_index += next_len;


  conf-> section_def_shm_index = next_index;
  DEBUG_PRINT(CONFIG_PROTO_LEVEL,
    ("start of default shm section index %u", 
     conf->section_def_shm_index));
  if ((ret= check_section(key_value,
                          conf-> section_def_shm_index,
                          FALSE)) !=0)
  {
    return ret;
  }
  next_len = g_ntohl(key_value[next_index]);
  next_index += next_len;


  conf-> section_def_system_index = next_index;
  DEBUG_PRINT(CONFIG_PROTO_LEVEL,
    ("start of system section index %u", 
      conf->section_def_system_index));
  if ((ret= check_section(key_value,
                          conf-> section_def_system_index,
                          TRUE)) !=0)
  {
    return ret;
  }
  next_len = g_ntohl(key_value[next_index]);
  next_index += next_len;

  
  guint32 total_nodes = g_ntohl(key_value[3]) + 
    g_ntohl(key_value[4]) + g_ntohl(key_value[5]);
  guint32 current_next_index = 0;
  guint32 node_id = 0;
  guint32 node_type = 0;
  for (guint32 i = 0; i < total_nodes; i++)
  {
    current_next_index = next_index;
    DEBUG_PRINT(CONFIG_PROTO_LEVEL,
    ("find nodeid nextindex %u",next_index));
    if ((ret= check_section(key_value,
                            next_index,
                            FALSE)) !=0)
    {
      return ret;
    }
    next_index = find_nodeid(next_index,
                             key_value,
                             &node_id,
                             &node_type);
   if (next_index == 0)
   {
     // handle error
   }
   DEBUG_PRINT(CONFIG_PROTO_LEVEL,
    ("total nodes %u, nodeid %u nodetype %u, start of section index %u",
     total_nodes, node_id, node_type, current_next_index));

   conf->node_section_ptrs[node_id] = current_next_index;
   conf->node_type_array[node_id] = (guint8)node_type; 
  }
  DEBUG_RETURN_PTR(conf);
}

